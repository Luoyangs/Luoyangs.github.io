<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>博客 - @Luoyangs</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="icon" type="image/x-icon" href="../../fav.png" />
	<link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css">
	<script src="https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js"></script>
	<script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
	<script src="../../static/js/underscore-min.js"></script>
	<style>
		.navbar{border-radius: 0px;margin-bottom:0px;}
		section{background:#EBEBEB;margin-top:0px;font-family: "Helvetica Neue", Helvetica, Arial, "Microsoft Yahei", "Hiragino Sans GB", "Heiti SC", "WenQuanYi Micro Hei", sans-serif;}
		#articleList{background:#fff;padding:16px;margin-top:20px;}
		.title{font-size:26px;text-align:center;font-weight:700;}
		.sub-title{font-size:16px;text-align:center;margin-left:32px;}
		#articleList span{display:block;margin-bottom:8px;line-height:20px;}
		#scrollspy > .nav {padding-left: 0px;background:#fff;margin-top:20px;padding:16px;min-width:250px;}
	  /* all anchors */
	  #scrollspy .nav > li > a {padding: 3px;border-left: 0px rgba(0,0,0,0);}
	  /* first level */
	  #scrollspy .nav li >  a {padding-left: 10px;}
	  /* second */
	  #scrollspy .nav .nav li >  a {padding-left: 20px;font-size:.9em;}
	  /* third */
	  #scrollspy .nav .nav .nav li >  a {padding-left: 30px;font-size:.8em;}
	  /* fourth */
	  #scrollspy .nav .nav .nav .nav li >  a {padding-left: 40px;}
	  /* fifth */
	  #scrollspy .nav .nav .nav .nav .nav li >  a {padding-left: 50px;}
	  /* active link */
	  #scrollspy li.active > a {font-weight:bold;border-left: 2px solid gray;}
	  /* hide second level lists */
	  #scrollspy .nav .nav {display:none;}
	  /* show second-level when active */
	  #scrollspy .nav > .active > .nav {display: block;}
	  /* headings on the page (easier to see h5, h6) */
	  #scrollspy h2, #scrollspy h3, #scrollspy h4, #scrollspy h5, #scrollspy h6 {font-style: italic;}
	</style>
</head>
<body>
	<nav class="navbar navbar-inverse navbar-fixed-top">
	  <div class="container-fluid">
	    <!-- Brand and toggle get grouped for better mobile display -->
	    <div class="navbar-header">
	      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
	        <span class="sr-only">Toggle navigation</span>
	        <span class="icon-bar"></span>
	        <span class="icon-bar"></span>
	        <span class="icon-bar"></span>
	      </button>
	      <a class="navbar-brand" href="#">博客在线</a>
	    </div>

	    <!-- Collect the nav links, forms, and other content for toggling -->
	    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
	      <ul class="nav navbar-nav">
	        <li><a href="/">首页 <span class="sr-only">(current)</span></a></li>
	        <li class="active"><a href="#">学习笔记</a></li>
	        <li><a href="#">实习经验</a></li>
	      </ul>
	      <ul class="nav navbar-nav navbar-right">
	        <li><a href="#">收藏</a></li>
	        <li class="dropdown">
	          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">@Luoyangs <span class="caret"></span></a>
	          <ul class="dropdown-menu">
	            <li><a href="#"><i class="glyphicon glyphicon-phone-alt"></i>&nbsp;&nbsp;手机</a></li>
	            <li><a href="#"><i class="glyphicon glyphicon-envelope"></i>&nbsp;&nbsp;Email</a></li>
	            <li><a href="#"><i class="glyphicon glyphicon-link"></i>&nbsp;&nbsp;QQ</a></li>
	          </ul>
	        </li>
	      </ul>
	    </div><!-- /.navbar-collapse -->
	  </div><!-- /.container-fluid -->
	</nav>
	<section style="margin-top:50px;">
		<div class="container-fluid">
			<div class="container">
				<div class="col-sm-9">
					<div id="articleList">
						<p class="title">ECMAScript 6新特性复习</p>
						<p class="sub-title">参考阮一峰es6博客学习笔记</p>
						<h2>1 let和const命令</h2>
		        <h3>1.1 基本用法</h3>
		        <p>
ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
<pre>
{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
</pre>
<span>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</span>
<span>for循环的计数器，就很合适使用let命令</span>
<pre>
for (let i = 0; i < 10; i++) {}

console.log(i);
//ReferenceError: i is not defined
</pre>
<span>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</span>
<span>下面的代码如果使用var，最后输出的是10。</span>
<pre>
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
</pre>
<span>上面代码中，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。</span>
<span>而如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。</span>
<pre>
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
</pre>
<span>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</span>
<span>要用var实现上面代码的效果，可使用闭包</span>
<pre>
var b = [];
for(var j = 0;j < 10; j++) {
  b[j] = (function(num){
    return function(){
      console.log(num);
    }
  })(j);
}
b[6]();
</pre>
<span>另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。</span>
<pre>
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
<span>上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。</span>
// abc
// abc
// abc
</pre>
		        </p>
		        <h4>1.1.1 不存在变量提升</h4>
		        <p>
<span>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</span>
<span>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</span>
<pre>
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</pre>
<span>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</span>
		        </p>
		        <h4>1.1.2 暂时性死区</h4>
		        <p>
<span>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</span>
<pre>
var tmp = 123;

if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
</pre>
<span>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</span>
<span>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</span>
<span>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）</span>
<pre>
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
</pre>
<span>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作</span>
<pre>
typeof x; // ReferenceError
let x;
</pre>
<span>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</span>
<span>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</span>
<pre>
typeof undeclared_variable // "undefined"
</pre>
<span>上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</span>
<span>有些“死区”比较隐蔽，不太容易发现。</span>
<pre>
function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错
</pre>
<span>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。</span>
<pre>
function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
</pre>
<span>另外，下面的代码也会报错，与var的行为不同。</span>
<pre>
// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
</pre>
<span>上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。</span>
<span>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</span>
<span>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</span>
		        </p>
		        <h4>1.1.3 不允许重复声明</h4>
		        <p>
<span>let不允许在相同作用域内，重复声明同一个变量。</span>
<pre>
// 报错
function () {
  let a = 10;
  var a = 1;
}

// 报错
function () {
  let a = 10;
  let a = 1;
}
</pre>
<span>因此，不能在函数内部重新声明参数。</span>
<pre>
function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
</pre>
		        </p>
		        <h3>1.2 块级作用域 </h3>
		        <h4>1.2.1 为什么需要块级作用域？</h4>
		        <p>
<span>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</span>
<span>第一种场景，内层变量可能会覆盖外层变量。</span>
<pre>
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
</pre>
<span>上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。即相当于下面的代码</span>
<pre>
var tmp = new Date();

function f() {
  var tmp;
  console.log(tmp);
  if (false) {
    tmp = 'hello world';
  }
}

f(); // undefined
</pre>
<span>第二种场景，用来计数的循环变量泄露为全局变量。</span>
<pre>
var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
</pre>
<span>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</span>
		       	</p>
		        <h4>1.2.2 ES6 的块级作用域</h4>
		        <p>
<span>let实际上为 JavaScript 新增了块级作用域。</span>
<pre>
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}

function f1() {
  var n = 5;
  if (true) {
    var n = 10;
  }
  console.log(n); // 10
}
</pre>
<span>上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。</span>
<span>ES6 允许块级作用域的任意嵌套。</span>
<pre>
{{{{{let insane = 'Hello World'}}}}};

{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};

{{{{
  let insane = 'Hello World';
  {let insane = 'Hello World'}
}}}};
</pre>
<span>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</span>
<pre>
// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
</pre>
		        </p>
		        <h4>1.2.3 块级作用域与函数声明</h4>
		        <p>
<span>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</span>        
<pre>
// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}
</pre>
<span>上面两种函数声明，根据 ES5 的规定都是非法的。</span>
<span>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</span>
<span>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</span>
<pre>
function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
</pre>
<span>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。</span>
<pre>
// ES5 环境
function f() { console.log('I am outside!'); }

(function () {
  function f() { console.log('I am inside!'); }
  if (false) {
  }
  f();
}());
</pre>
<span>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</span>
<span>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式:允许在块级作用域内声明函数;函数声明类似于var，即会提升到全局作用域或函数作用域的头部;同时，函数声明还会提升到所在的块级作用域的头部。</span>
<span>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</span>
<pre>
// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</pre>
<span>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。</span>
<pre>
// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</pre>
<span>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</span>
<pre>
// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
</pre>
<span>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</span>
<pre>
// 不报错
'use strict';
if (true) {
  function f() {}
}

// 报错
'use strict';
if (true)
  function f() {}
</pre>
		        </p>
		        <h3>1.3 const 命令</h3>
		        <h4>1.3.1 基本用法</h4>
		        <p>
<span>const声明一个只读的常量。一旦声明，常量的值就不能改变。</span>
<pre>
const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
</pre>
<span>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</span>
<pre>
const foo;
// SyntaxError: Missing initializer in const declaration
</pre>
<span>上面代码表示，对于const来说，只声明不赋值，就会报错。</span>
<span>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</span>
<pre>
if (true) {
  const MAX = 5;
}

MAX // Uncaught ReferenceError: MAX is not defined
</pre>
<span>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</span>
<pre>
if (true) {
  console.log(MAX); // ReferenceError
  const MAX = 5;
}
</pre>
<span>const声明的常量，也与let一样不可重复声明。</span>
<pre>
var message = "Hello!";
let age = 25;

// 以下两行都会报错
const message = "Goodbye!";
const age = 30;
</pre>
		       	</p>
		        <h4>1.3.2 const本质</h4>
		        <p>
<span>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</span>
<pre>
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
</pre>
<span>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</span>
<pre>
const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
</pre>
<span>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</span>
<span>如果真的想将对象冻结，应该使用Object.freeze方法。</span>
<pre>
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
</pre>
<span>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</span>
<pre>
var constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) => {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};
</pre>
		        </p>
		        <h4>1.3.3 ES6 声明变量的六种方法</h4>
		        <p>ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。</p>
		        <h3>1.4 顶层对象的属性</h3>
		        <p>
<span>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的</span>
<pre>
window.a = 1;
a // 1

a = 2;
window.a // 2
</pre>		        
<span>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</span>
<span>ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</span>        
<pre>
var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined
</pre>
		        </p>
						<h3>1.5 global 对象</h3>
						<p>
<span>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的:(1)浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window;(2)浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self;Node 里面，顶层对象是global，但其他环境都不支持。</span>
<span>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性:(1)全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块;(2)函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined;(3)不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</span>
<span>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法</span>
<pre>
// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
</pre>
						</p>
		        <h2>2 变量的解构赋值</h2>
		        <h3>2.1 数组的解构赋值</h3>
		        <h4>2.1.1 基本用法</h4>
		        <p>
<span>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</span>
<span>以前，为变量赋值，只能直接指定值。</span>
<pre>
let a = 1;
let b = 2;
let c = 3;
</pre>
<span>ES6允许写成下面这样。</span>
<pre>
let [a, b, c] = [1, 2, 3];
</pre>
<span>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</span>
<span>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</span>
<pre>
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
</pre>
<span>如果解构不成功，变量的值就等于undefined。</span>
<pre>
let [foo] = [];
let [bar, foo] = [1];
</pre>
<span>以上两种情况都属于解构不成功，foo的值都会等于undefined。</span>
<span>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</span>
<pre>
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
</pre>
<span>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</span>
<pre>
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
</pre>
<span>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</span>
<span>对于 Set 结构，也可以使用数组的解构赋值。</span>
<pre>
let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"
</pre>
<span>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</span>
<pre>
function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
</pre>
		        </p>
		        <h4>2.1.2 默认值</h4>
		        <p>
<span>解构赋值允许指定默认值。</span>
<pre>
let [foo = true] = [];
foo // true

let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
</pre>
<span>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</span>
<pre>
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
</pre>
<span>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</span>
<span>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</span>
<pre>
function f() {
  console.log('aaa');
}

let [x = f()] = [1];
</pre>
<span>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码</span>
<pre>
let x;
if ([1][0] === undefined) {
  x = f();
} else {
  x = [1][0];
}
</pre>
<span>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</span>
<pre>
let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError
</pre>
<span>上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。</span>
		       	</p>
		        <h3>2.2 对象的解构赋值</h3>
		        <p>
<span>解构不仅可以用于数组，还可以用于对象</span>
<pre>
let { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
</pre>
<span>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</span>
<pre>
let { bar, foo } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: "aaa", bar: "bbb" };
baz // undefined
</pre>
<span>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</span>
<span>如果变量名与属性名不一致，必须写成下面这样。</span>
<pre>
var { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
</pre>
<span>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</span>
<pre>
let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
</pre>
<span>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</span>
<pre>
let { foo: baz } = { foo: "aaa", bar: "bbb" };
baz // "aaa"
foo // error: foo is not defined
</pre>
<span>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</span>
<span>注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</span>
<pre>
let foo;
let {foo} = {foo: 1}; // SyntaxError: Duplicate declaration "foo"

let baz;
let {bar: baz} = {bar: 1}; // SyntaxError: Duplicate declaration "baz"
</pre>
<span>上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。</span>
<pre>
let foo;
({foo} = {foo: 1}); // 成功

let baz;
({bar: baz} = {bar: 1}); // 成功
</pre>
<span>上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。</span>
<span>和数组一样，解构也可以用于嵌套结构的对象。</span>
<pre>
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p: [x, { y }] } = obj;
x // "Hello"
y // "World"
</pre>
<span>注意，这时p是模式，不是变量，因此不会被赋值。</span>
<pre>
var node = {
  loc: {
    start: {
      line: 1,
      column: 5
    }
  }
};

var { loc: { start: { line }} } = node;
line // 1
loc  // error: loc is undefined
start // error: start is undefined
</pre>
<span>上面代码中，只有line是变量，loc和start都是模式，不会被赋值。</span>
<span>下面是嵌套赋值的例子。</span>
<pre>
let obj = {};
let arr = [];

({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

obj // {prop:123}
arr // [true]
</pre>
<span>对象的解构也可以指定默认值。</span>
<pre>
var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x:y = 3} = {};
y // 3

var {x:y = 3} = {x: 5};
y // 5

var { message: msg = 'Something went wrong' } = {};
msg // "Something went wrong"
</pre>
<span>默认值生效的条件是，对象的属性值严格等于undefined。</span>
<pre>
var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
</pre>
<span>上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。</span>
<span>如果解构失败，变量的值等于undefined。</span>	        
<pre>
let {foo} = {bar: 'baz'};
foo // undefined
</pre>
<span>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</span>
<pre>
// 报错
let {foo: {bar}} = {baz: 'baz'};
</pre>
<span>上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。</span>
<pre>
let _tmp = {baz: 'baz'};
_tmp.foo.bar // 报错
</pre>
<span>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</span>
<pre>
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
</pre>
<span>上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</span>
<pre>
// 正确的写法
({x} = {x: 1});
</pre>
<span>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</span>
<span>解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</span>
<pre>
({} = [true, false]);
({} = 'abc');
({} = []);
</pre>
<span>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</span>
<span>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</span>
<pre>
let { log, sin, cos } = Math;
</pre>
<span>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</span>
<span>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</span>
<pre>
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
</pre>
<span>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。</span>
		        </p>
		        <h3>2.3 字符串的解构赋值</h3>
		        <p>
<span>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</span>
<pre>
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
</pre>
<span>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</span>
<pre>
let {length : len} = 'hello';
len // 5
</pre>
		        </p>
		        <h3>2.4 数值和布尔值的解构赋值 </h3>
		        <p>
<span>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</span>
<pre>
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
</pre>
<span>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</span>
<span>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</span>
<pre>
let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
</pre>
		        </p>
		        <h3>2.5 函数参数的解构赋值</h3>
		        <p>
<span>函数的参数也可以使用解构赋值。</span>
<pre>
function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
</pre>
<span>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</span>
<pre>
[[1, 2], [3, 4]].map(([a, b]) => a + b);
// [ 3, 7 ]
</pre>
<span>函数参数的解构也可以使用默认值。</span>
<pre>
function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</pre>
<span>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</span>
<span>注意，下面的写法会得到不一样的结果。</span>
<pre>
function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
</pre>
<span>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</span>
<span>undefined就会触发函数参数的默认值。</span>
<pre>
[1, undefined, 3].map((x = 'yes') => x);
// [ 1, 'yes', 3 ]
</pre>
		        </p>
		        <h3>2.6 圆括号问题</h3>
		        <p>
<span>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</span>
<span>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</span>
<span>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</span>
		        </p>
		        <h4>2.6.1 不能使用圆括号的情况</h4>
		        <p>
<span>以下三种解构赋值不得使用圆括号。</span>
<span>（1）变量声明语句中，不能带有圆括号。</span>
<pre>
// 全部报错
let [(a)] = [1];

let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};

let { o: ({ p: p }) } = { o: { p: 2 } };
</pre>
<span>上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</span>
<span>（2）函数参数中，模式不能带有圆括号。</span>
<span>函数参数也属于变量声明，因此不能带有圆括号。</span>
<pre>
// 报错
function f([(z)]) { return z; }
</pre>
<span>（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</span>
<pre>
// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
</pre>
<span>上面代码将整个模式放在圆括号之中，导致报错。</span>
<pre>
// 报错
[({ p: a }), { x: c }] = [{}, {}];
</pre>
<span>上面代码将嵌套模式的一层，放在圆括号之中，导致报错。</span>
		        </p>
		        <h4>2.6.2 可以使用圆括号的情况</h4>
		        <p>
<span>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</span>
<pre>
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
</pre>
<span>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</span>
		        </p>
		        <h3>2.7 用途</h3>
		        <p>
<span>变量的解构赋值用途很多。</span>
<span>（1）交换变量的值</span>
<pre>
let x = 1;
let y = 2;

[x, y] = [y, x];
</pre>
<span>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</span>
<span>（2）从函数返回多个值</span>
<span>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</span>
<pre>
// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
</pre>		        
<span>（3）函数参数的定义</span>
<span>解构赋值可以方便地将一组参数与变量名对应起来</span>
<pre>
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
</pre>
<span>（4）提取JSON数据</span>
<span>解构赋值对提取JSON对象中的数据，尤其有用。</span>
<pre>
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, "OK", [867, 5309]
</pre>
<span>上面代码可以快速提取 JSON 数据的值。</span>
<span>（5）函数参数的默认值</span>
<pre>
jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};
</pre>
<span>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。</span>
<span>（6）遍历Map结构</span>
<span>任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</span>
<pre>
var map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world

// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
</pre>
<span>（7）输入模块的指定方法</span>
<span>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</span>
<pre>
const { SourceMapConsumer, SourceNode } = require("source-map");
</pre>
		        </p>
		        <h2>3 字符串的扩展</h2>
		        <p><span>ES6加强了对Unicode的支持，并且扩展了字符串对象。</span></p>
		        <h3>3.1 字符的Unicode表示法</h3>
		        <p>
<span>JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。</span>
<pre>
"\u0061"
// "a"
</pre>
<span>但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</span>
<span>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</span>
<pre>

</pre>
<span>有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。</span>
<pre>
'\z' === 'z'  // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // tru
</pre>
		        </p>
		        <h3>3.2 codePointAt()</h3>
		        <p>
<span>JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。</span>
<span>总之，codePointAt方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。</span>
<span>codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。</span>
<span>你可能注意到了，codePointAt方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是1，但是必须向codePointAt方法传入2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别32位的UTF-16字符。</span>
		        </p>
		        <h3>3.3 String.fromCodePoint()</h3>
		        <p>
<span>ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。</span>
<pre>
String.fromCharCode(0x20BB7)
// "ஷ"
</pre>
<span>上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。</span>
<span>ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</span>
<pre>
String.fromCodePoint(0x20BB7)
String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'
// true
</pre>
<span>上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。</span>
<span>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</span>
		        </p>
		        <h3>3.4 字符串的遍历器接口</h3>
		        <p>
<span>ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。</span>
<pre>
for (let codePoint of 'foo') {
  console.log(codePoint)
}
// "f"
// "o"
// "o"
</pre>
<span>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</span>
<pre>
var text = String.fromCodePoint(0x20BB7);

for (let i = 0; i < text.length; i++) {
  console.log(text[i]);
}
// " "
// " "

for (let i of text) {
  console.log(i);
}
</pre>
<span>上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for...of循环会正确识别出这一个字符。</span>		
		        </p>
		        <h3>3.5 at()</h3>
		        <p>
<span>ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。</span>
<span>目前，有一个提案，提出字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。</span>
		        </p>
		        <h3>3.6 normalize()</h3>
		        <p>
<span>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。</span>
<span>ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</span>
		        </p>
		        <h3>3.7 includes(), startsWith(), endsWith()</h3>
		        <p>
<span>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法:(1)includes()：返回布尔值，表示是否找到了参数字符串。(2)startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。(3)endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</span>
<pre>
var s = 'Hello world!';

s.startsWith('Hello') // true
s.endsWith('!') // true
s.includes('o') // true
</pre>
<span>这三个方法都支持第二个参数，表示开始搜索的位置。</span>
<pre>
var s = 'Hello world!';

s.startsWith('world', 6) // true
s.endsWith('Hello', 5) // true
s.includes('Hello', 6) // false
</pre>
<span>上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</span>
		        </p>
		        <h3>3.8 repeat() </h3>
		        <p>
<span>repeat方法返回一个新字符串，表示将原字符串重复n次</span>
<pre>
'x'.repeat(3) // "xxx"
'hello'.repeat(2) // "hellohello"
'na'.repeat(0) // ""
</pre>
<span>参数如果是小数，会被取整。</span>
<pre>
'na'.repeat(2.9) // "nana"
</pre>
<span>如果repeat的参数是负数或者Infinity，会报错。</span>
<pre>
'na'.repeat(Infinity)
// RangeError
'na'.repeat(-1)
// RangeError
</pre>
<span>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。</span>
<pre>
'na'.repeat(-0.9) // ""
</pre>
<span>参数NaN等同于0。</span>	   
<pre>
'na'.repeat(NaN) // ""
</pre>     
<span>如果repeat的参数是字符串，则会先转换成数字。</span>
<pre>
'na'.repeat('na') // ""
'na'.repeat('3') // "nanana"
</pre>
		        </p>
		        <h3>3.9 padStart()，padEnd()</h3>
		        <p>
<span>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</span>
<pre>
'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'

'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'
</pre>
<span>上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</span>
<span>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</span>
<pre>
'xxx'.padStart(2, 'ab') // 'xxx'
'xxx'.padEnd(2, 'ab') // 'xxx'
</pre>
<span>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</span>
<pre>
'abc'.padStart(10, '0123456789')
// '0123456abc'
</pre>
<span>如果省略第二个参数，默认使用空格补全长度。</span>
<pre>
'x'.padStart(4) // '   x'
'x'.padEnd(4) // 'x   '
</pre>
<span>padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。</span>
<pre>
'1'.padStart(10, '0') // "0000000001"
'12'.padStart(10, '0') // "0000000012"
'123456'.padStart(10, '0') // "0000123456"
</pre>
<span>另一个用途是提示字符串格式。</span>
<pre>
'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
</pre>
		        </p>
		        <h3>3.10 模板字符串</h3>
		        <p>
<span>传统的JavaScript语言，输出模板通常是这样写的。</span>
<pre>
$('#result').append(
  'There are <b>' + basket.count + '</b> ' +
  'items in your basket, ' +
  '<em>' + basket.onSale +
  '</em> are on sale!'
);
</pre>
<span>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。</span>
<pre>
$('#result').append(`
  There are <b>${basket.count}</b> items
   in your basket, <em>${basket.onSale}</em>
  are on sale!
`);
</pre>
<span>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</span>
<pre>
// 普通字符串
`In JavaScript '\n' is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
var name = "Bob", time = "today";
`Hello ${name}, how are you ${time}?`
</pre>
<span>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</span>
<pre>
var greeting = `\`Yo\` World!`;
</pre>
<span>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</span>
<pre>
$('#list').html(`
<ul>
  <li>first</li>
  <li>second</li>
</ul>
`);
</pre>
<span>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如ul标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。</span>
<pre>
$('#list').html(`
<ul>
  <li>first</li>
  <li>second</li>
</ul>
`.trim());
</pre>
<span>模板字符串中嵌入变量，需要将变量名写在${}之中。</span>
<pre>
function authorize(user, action) {
  if (!user.hasPrivilege(action)) {
    throw new Error(
      // 传统写法为
      // 'User '
      // + user.name
      // + ' is not authorized to do '
      // + action
      // + '.'
      `User ${user.name} is not authorized to do ${action}.`);
  }
}
</pre>
<span>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</span>
<pre>
var x = 1;
var y = 2;

`${x} + ${y} = ${x + y}`
// "1 + 2 = 3"

`${x} + ${y * 2} = ${x + y * 2}`
// "1 + 4 = 5"

var obj = {x: 1, y: 2};
`${obj.x + obj.y}`
// 3
</pre>
<span>模板字符串之中还能调用函数。</span>
<pre>
function fn() {
  return "Hello World";
}

`foo ${fn()} bar`
// foo Hello World bar
</pre>
<span>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</span>
<span>如果模板字符串中的变量没有声明，将报错。</span>
<pre>
// 变量place没有声明
var msg = `Hello, ${place}`;
// 报错
</pre>
<span>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。</span>
<pre>
`Hello ${'World'}`
// "Hello World"
</pre>
<span>模板字符串甚至还能嵌套。</span>
<pre>
const tmpl = addrs => `
  <table>
  ${addrs.map(addr => `
    <tr><td>${addr.first}</td></tr>
    <tr><td>${addr.last}</td></tr>
  `).join('')}
  </table>
`;
</pre>
<span>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</span>
<pre>
const data = [
    { first: '<Jane>', last: 'Bond' },
    { first: 'Lars', last: '<Croft>' },
];

console.log(tmpl(data));
// &lt;table&gt;
//
//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;
//
//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;
//
// &lt;/table&gt;
</pre>
<span>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</span>
<pre>
// 写法一
let str = 'return ' + '`Hello ${name}!`';
let func = new Function('name', str);
func('Jack') // "Hello Jack!"

// 写法二
let str = '(name) => `Hello ${name}!`';
let func = eval.call(null, str);
func('Jack') // "Hello Jack!"
</pre>
		        </p>
		        <h3>3.11 实例：模板编译</h3>
		        <p>
<span>下面，我们来看一个通过模板字符串，生成正式模板的实例</span>
<pre>
var template = `
&lt;ul&gt;
  &lt;% for(var i=0; i &lt; data.supplies.length; i++) { %&gt;
    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;
  &lt;% } %&gt;
&lt;/ul&gt;
`;
</pre>	
<span>上面代码在模板字符串之中，放置了一个常规模板。该模板使用<%...%>放置JavaScript代码，使用<%= ... %>输出JavaScript表达式。</span>	       	
<span>怎么编译这个模板字符串呢？</span>
<span>一种思路是将其转换为JavaScript表达式字符串。</span>
<pre>
echo('&lt;ul&gt;');
for(var i=0; i &lt; data.supplies.length; i++) {
  echo('&lt;li&gt;');
  echo(data.supplies[i]);
  echo('&lt;/li&gt;');
};
echo('&lt;/ul&gt;');
</pre>
<span>这个转换使用正则表达式就行了。</span>
<pre>
var evalExpr = /<%=(.+?)%>/g;
var expr = /<%([\s\S]+?)%>/g;

template = template
  .replace(evalExpr, '`); \n  echo( $1 ); \n  echo(`')
  .replace(expr, '`); \n $1 \n  echo(`');

template = 'echo(`' + template + '`);';
</pre>
<span>将上面的内容拼装成一个模板编译函数compile</span>
<pre>
function compile(template){
  var evalExpr = /<%=(.+?)%>/g;
  var expr = /<%([\s\S]+?)%>/g;

  template = template
    .replace(evalExpr, '`); \n  echo( $1 ); \n  echo(`')
    .replace(expr, '`); \n $1 \n  echo(`');

  template = 'echo(`' + template + '`);';

  var script =
  `(function parse(data){
    var output = "";

    function echo(html){
      output += html;
    }

    ${ template }

    return output;
  })`;

  return script;
}
</pre>
<span>compile函数的用法如下。</span>
<pre>
var parse = eval(compile(template));
div.innerHTML = parse({ supplies: [ "broom", "mop", "cleaner" ] });
//   &lt;ul&gt;
//     &lt;li&gt;broom&lt;/li&gt;
//     &lt;li&gt;mop&lt;/li&gt;
//     &lt;li&gt;cleaner&lt;/li&gt;
//   &lt;/ul&gt;
</pre>
		       	</p>
		        <h3>3.12 标签模板</h3>
		        <p>
<span>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</span>
<pre>
alert`123`
// 等同于
alert(123)
</pre>
<span>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</span>
<span>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</span>
<pre>
var a = 5;
var b = 10;

tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag(['Hello ', ' world ', ''], 15, 50);
</pre>
<span>上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</span>
<span>函数tag依次会接收到多个参数。</span>
<pre>
function tag(stringArr, value1, value2){
  // ...
}

// 等同于

function tag(stringArr, ...values){
  // ...
}
</pre>
<span>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</span>
<span>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</span>
		        </p>
		        <h3>3.13 String.raw() </h3>
		        <p>
<span>ES6还为原生的String对象，提供了一个raw方法。</span>
<span>String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</span>
<pre>
String.raw`Hi\n${2+3}!`;
// "Hi\\n5!"

String.raw`Hi\u000A!`;
// 'Hi\\u000A!'
</pre>
<span>如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。</span>
<pre>
String.raw`Hi\\n`
// "Hi\\n"
</pre>
<span>String.raw的代码基本如下</span>
<pre>
String.raw = function (strings, ...values) {
  var output = "";
  for (var index = 0; index < values.length; index++) {
    output += strings.raw[index] + values[index];
  }

  output += strings.raw[index]
  return output;
}
</pre>
<span>String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</span>
<span>String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</span>
<pre>
String.raw({ raw: 'test' }, 0, 1, 2);
// 't0e1s2t'

// 等同于
String.raw({ raw: ['t','e','s','t'] }, 0, 1, 2);
</pre>
		        </p>
		        <h2>4 正则的扩展</h2>
		        <h3>4.1 RegExp构造函数</h3>
		        <p>
<span>在ES5中，RegExp构造函数的参数有两种情况。</span>
<span>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</span>
<pre>
var regex = new RegExp('xyz', 'i');
// 等价于
var regex = /xyz/i;
</pre>
<span>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</span>
<pre>
var regex = new RegExp(/xyz/i);
// 等价于
var regex = /xyz/i;
</pre>
<span>但是，ES5不允许此时使用第二个参数，添加修饰符，否则会报错。</span>
<pre>
var regex = new RegExp(/xyz/, 'i');
// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another
</pre>
<span>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</span>
<pre>
new RegExp(/abc/ig, 'i').flags
// "i"
</pre>
<span>上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖</span>
		        </p>
		        <h3>4.2 字符串的正则方法</h3>
		        <p>
<span>字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。</span>
<span>ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上:<br> (1)String.prototype.match 调用 RegExp.prototype[Symbol.match];<br>(2)String.prototype.replace 调用 RegExp.prototype[Symbol.replace];<br>(3)String.prototype.search 调用 RegExp.prototype[Symbol.search];<br>(4)String.prototype.split 调用 RegExp.prototype[Symbol.split]</span>
		        </p>
		        <h3>4.3 u修饰符</h3>
		        <p>
<span>ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</span>
<pre>
/^\uD83D/u.test('\uD83D\uDC2A')
// false
/^\uD83D/.test('\uD83D\uDC2A')
// true
</pre>
<span>上面代码中，\uD83D\uDC2A是一个四个字节的UTF-16编码，代表一个字符。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为false。</span>
<span>一旦加上u修饰符号，就会修改下面这些正则表达式的行为。</span>
<span>（1）点字符</span>
<span>点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符。</span>
<pre>
var s = '[][]]';

/^.$/.test(s) // false
/^.$/u.test(s) // true
</pre>
<span>上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</span>
<span>（2）Unicode字符表示法</span>
<span>ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。</span>
<pre>
/\u{61}/.test('a') // false
/\u{61}/u.test('a') // true
</pre>
<span>上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配61个连续的u。</span>
<span>（3）量词</span>
<span>使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。</span>
<pre>
/a{2}/.test('aa') // true
/a{2}/u.test('aa') // true
</pre>
<span>另外，只有在使用u修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。</span>
<pre>
/^\u{3}$/.test('uuu') // true
</pre>
<span>上面代码中，由于正则表达式没有u修饰符，所以大括号被解读为量词。加上u修饰符，就会被解读为Unicode表达式。</span>
		        </p>
		        <h3>4.4 y 修饰符</h3>
		        <p>
<span>除了u修饰符，ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</span>
<pre>
var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
</pre>
<span>上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。</span>
<span>如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。</span>
<pre>
var s = 'aaa_aa_a';
var r = /a+_/y;

r.exec(s) // ["aaa_"]
r.exec(s) // ["aa_"]
</pre>
<span>上面代码每次匹配，都是从剩余字符串的头部开始。</span>
<span>使用lastIndex属性，可以更好地说明y修饰符。</span>
<pre>
const REGEX = /a/g;

// 指定从2号位置（y）开始匹配
REGEX.lastIndex = 2;

// 匹配成功
const match = REGEX.exec('xaya');

// 在3号位置匹配成功
match.index // 3

// 下一次匹配从4号位开始
REGEX.lastIndex // 4

// 4号位开始匹配失败
REGEX.exec('xaxa') // null
</pre>
<span>上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。</span>
<span>y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。</span>
<pre>
const REGEX = /a/y;

// 指定从2号位置开始匹配
REGEX.lastIndex = 2;

// 不是粘连，匹配失败
REGEX.exec('xaya') // null

// 指定从3号位置开始匹配
REGEX.lastIndex = 3;

// 3号位置是粘连，匹配成功
const match = REGEX.exec('xaxa');
match.index // 3
REGEX.lastIndex // 4
</pre>
<span>进一步说，y修饰符号隐含了头部匹配的标志^。</span>
<pre>
/b/y.exec('aba')
// null
</pre>
<span>上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</span>
<span>在split方法中使用y修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。</span>
<pre>
// 没有找到匹配
'x##'.split(/#/y)
// [ 'x##' ]

// 找到两个匹配
'##x'.split(/#/y)
// [ '', '', 'x' ]
</pre>
<span>后续的分隔符只有紧跟前面的分隔符，才会被识别。</span>
<pre>
'#x#'.split(/#/y)
// [ '', 'x#' ]

'##'.split(/#/y)
// [ '', '', '' ]
</pre>
<span>下面是字符串对象的replace方法的例子。</span>
<pre>
const REGEX = /a/gy;
'aaxa'.replace(REGEX, '-') // '--xa'
</pre>
<span>上面代码中，最后一个a因为不是出现下一次匹配的头部，所以不会被替换。</span>
<span>单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。</span>
<pre>
'a1a2a3'.match(/a\d/y) // ["a1"]
'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"]
</pre>
<span>y修饰符的一个应用，是从字符串提取token（词元），y修饰符确保了匹配之间不会有漏掉的字符。</span>
<pre>
const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;
const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;

tokenize(TOKEN_Y, '3 + 4')
// [ '3', '+', '4' ]
tokenize(TOKEN_G, '3 + 4')
// [ '3', '+', '4' ]

function tokenize(TOKEN_REGEX, str) {
  let result = [];
  let match;
  while (match = TOKEN_REGEX.exec(str)) {
    result.push(match[1]);
  }
  return result;
}
</pre>
<span>上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</span>
<pre>
tokenize(TOKEN_Y, '3x + 4')
// [ '3' ]
tokenize(TOKEN_G, '3x + 4')
// [ '3', '+', '4' ]
</pre>
<span>上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。</span>
		        </p>
		        <h3>4.5 sticky属性</h3>
		        <p>
<span>与y修饰符相匹配，ES6的正则对象多了sticky属性，表示是否设置了y修饰符。</span>
<pre>
var r = /hello\d/y;
r.sticky // true
</pre>
		        </p>
		        <h3>4.6 flags属性</h3>
		        <p>
<span>ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。</span>
<pre>// ES5的source属性
// 返回正则表达式的正文
/abc/ig.source
// "abc"

// ES6的flags属性
// 返回正则表达式的修饰符
/abc/ig.flags
// 'gi'
</pre>
		        </p>
		        <h3>4.7 RegExp.escape() </h3>
		        <p>
<span>字符串必须转义，才能作为正则模式。</span>
<pre>
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}

let str = '/path/to/resource.html?search=query';
escapeRegExp(str)
// "\/path\/to\/resource\.html\?search=query"
</pre>
		        </p>
		        <h2>5 数值的扩展</h2>
		        <h3>5.1 二进制和八进制表示法</h3>
		        <p>
<span>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</span>
<pre>
0b111110111 === 503 // true
0o767 === 503 // true	
</pre>
<span>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示</span>
<pre>
// 非严格模式
(function(){
  console.log(0o11 === 011);
})() // true

// 严格模式
(function(){
  'use strict';
  console.log(0o11 === 011);
})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.
</pre>		        
<span>如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。</span>
<pre>
Number('0b111')  // 7
Number('0o10')  // 8
</pre>
		        </p>
		        <h3>5.2 Number.isFinite(), Number.isNaN()</h3>
		        <p>
<span>ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。</span>
<span>Number.isFinite()用来检查一个数值是否为有限的（finite）</span>
<pre>
Number.isFinite(15); // true
Number.isFinite(0.8); // true
Number.isFinite(NaN); // false
Number.isFinite(Infinity); // false
Number.isFinite(-Infinity); // false
Number.isFinite('foo'); // false
Number.isFinite('15'); // false
Number.isFinite(true); // false
</pre>
<span>ES5可以通过下面的代码，部署Number.isFinite方法。</span>
<pre>
(function (global) {
  var global_isFinite = global.isFinite;

  Object.defineProperty(Number, 'isFinite', {
    value: function isFinite(value) {
      return typeof value === 'number' && global_isFinite(value);
    },
    configurable: true,
    enumerable: false,
    writable: true
  });
})(this);
</pre>
<span>Number.isNaN()用来检查一个值是否为NaN。</span>
<pre>
Number.isNaN(NaN) // true
Number.isNaN(15) // false
Number.isNaN('15') // false
Number.isNaN(true) // false
Number.isNaN(9/NaN) // true
Number.isNaN('true'/0) // true
Number.isNaN('true'/'true') // true
</pre>
<span>ES5通过下面的代码，部署Number.isNaN()。</span>
<pre>
(function (global) {
  var global_isNaN = global.isNaN;

  Object.defineProperty(Number, 'isNaN', {
    value: function isNaN(value) {
      return typeof value === 'number' && global_isNaN(value);
    },
    configurable: true,
    enumerable: false,
    writable: true
  });
})(this);
</pre>
<span>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。</span>
<pre>
isFinite(25) // true
isFinite("25") // true
Number.isFinite(25) // true
Number.isFinite("25") // false

isNaN(NaN) // true
isNaN("NaN") // true
Number.isNaN(NaN) // true
Number.isNaN("NaN") // false
</pre>
		        </p>
		        <h3>5.3 Number.parseInt(), Number.parseFloat()</h3>
		        <p>
<span>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</span>
<pre>
// ES5的写法
parseInt('12.34') // 12
parseFloat('123.45#') // 123.45

// ES6的写法
Number.parseInt('12.34') // 12
Number.parseFloat('123.45#') // 123.45
</pre>
<span>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</span>
<pre>
Number.parseInt === parseInt // true
Number.parseFloat === parseFloat // true
</pre>

		        </p>
		        <h3>5.4 Number.isInteger()</h3>
		        <p>
<span>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</span>
<pre>
Number.isInteger(25) // true
Number.isInteger(25.0) // true
Number.isInteger(25.1) // false
Number.isInteger("15") // false
Number.isInteger(true) // false
</pre>
<span>ES5可以通过下面的代码，部署Number.isInteger()。</span>
<pre>
(function (global) {
  var floor = Math.floor,
    isFinite = global.isFinite;

  Object.defineProperty(Number, 'isInteger', {
    value: function isInteger(value) {
      return typeof value === 'number' && isFinite(value) &&
        value > -9007199254740992 && value < 9007199254740992 &&
        floor(value) === value;
    },
    configurable: true,
    enumerable: false,
    writable: true
  });
})(this);
</pre>
		        </p>
		        <h3>5.4 Number.EPSILON</h3>
					  <p>
<span>ES6在Number对象上面，新增一个极小的常量Number.EPSILON。</span>
<pre>
Number.EPSILON
// 2.220446049250313e-16
Number.EPSILON.toFixed(20)
// '0.00000000000000022204'
</pre>
<span>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</span>
<pre>
0.1 + 0.2
// 0.30000000000000004

0.1 + 0.2 - 0.3
// 5.551115123125783e-17

5.551115123125783e-17.toFixed(20)
// '0.00000000000000005551'
</pre>
<span>但是如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。</span>
<pre>
5.551115123125783e-17 < Number.EPSILON
// true
</pre>
<span>因此，Number.EPSILON的实质是一个可以接受的误差范围。</span>
<pre>
function withinErrorMargin (left, right) {
  return Math.abs(left - right) < Number.EPSILON;
}
withinErrorMargin(0.1 + 0.2, 0.3)
// true
withinErrorMargin(0.2 + 0.2, 0.3)
// false
</pre>
					  </p>
						<h3>5.5 安全整数和Number.isSafeInteger() </h3>
						<p>
<span>JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</span>
<pre>
Math.pow(2, 53) // 9007199254740992

9007199254740992  // 9007199254740992
9007199254740993  // 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1
// true
</pre>
<span>上面代码中，超出2的53次方之后，一个数就不精确了。</span>
<span>ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</span>
<pre>
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
// true
Number.MAX_SAFE_INTEGER === 9007199254740991
// true

Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER
// true
Number.MIN_SAFE_INTEGER === -9007199254740991
// true
</pre>
<span>上面代码中，可以看到JavaScript能够精确表示的极限。</span>
<span>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</span>
<pre>
Number.isSafeInteger('a') // false
Number.isSafeInteger(null) // false
Number.isSafeInteger(NaN) // false
Number.isSafeInteger(Infinity) // false
Number.isSafeInteger(-Infinity) // false

Number.isSafeInteger(3) // true
Number.isSafeInteger(1.2) // false
Number.isSafeInteger(9007199254740990) // true
Number.isSafeInteger(9007199254740992) // false

Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false
Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true
Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true
Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false
</pre>
<span>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</span>
<pre>
Number.isSafeInteger = function (n) {
  return (typeof n === 'number' &&
    Math.round(n) === n &&
    Number.MIN_SAFE_INTEGER <= n &&
    n <= Number.MAX_SAFE_INTEGER);
}
</pre>
<span>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</span>
<pre>
Number.isSafeInteger(9007199254740993)
// false
Number.isSafeInteger(990)
// true
Number.isSafeInteger(9007199254740993 - 990)
// true
9007199254740993 - 990
// 返回结果 9007199254740002
// 正确答案应该是 9007199254740003
</pre>
<span>上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。</span>
<pre>
9007199254740993 === 9007199254740992
// true
</pre>
<span>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</span>
<pre>
function trusty (left, right, result) {
  if (
    Number.isSafeInteger(left) &&
    Number.isSafeInteger(right) &&
    Number.isSafeInteger(result)
  ) {
    return result;
  }
  throw new RangeError('Operation cannot be trusted!');
}

trusty(9007199254740993, 990, 9007199254740993 - 990)
// RangeError: Operation cannot be trusted!

trusty(1, 2, 3)
// 3
</pre>
						</p>
						<h2>6 Math对象的扩展 </h2>
						<p>
<span>ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。</span>
</p>
						<h3>6.1 Math.trunc() </h3>
						<p>
<span>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</span>
<pre>
Math.trunc(4.1) // 4
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4
Math.trunc(-4.9) // -4
Math.trunc(-0.1234) // -0
</pre>
<span>对于非数值，Math.trunc内部使用Number方法将其先转为数值。</span>
<pre>
Math.trunc('123.456')
// 123
</pre>
<span>对于空值和无法截取整数的值，返回NaN。</span>
<pre>
Math.trunc(NaN);      // NaN
Math.trunc('foo');    // NaN
Math.trunc();         // NaN
</pre>
<span>对于没有部署这个方法的环境，可以用下面的代码模拟。</span>
<pre>
Math.trunc = Math.trunc || function(x) {
  return x < 0 ? Math.ceil(x) : Math.floor(x);
};
</pre>
						</p>
						<h3>6.2 Math.sign() </h3>
						<p>
<span>Math.sign方法用来判断一个数到底是正数、负数、还是零。</span>
<span>它会返回五种值:<br>
参数为正数，返回+1；<br>
参数为负数，返回-1；<br>
参数为0，返回0；<br>
参数为-0，返回-0;<br>
其他值，返回NaN。</span>
<pre>
Math.sign(-5) // -1
Math.sign(5) // +1
Math.sign(0) // +0
Math.sign(-0) // -0
Math.sign(NaN) // NaN
Math.sign('foo'); // NaN
Math.sign();      // NaN
</pre>
<span>对于没有部署这个方法的环境，可以用下面的代码模拟。</span>
<pre>
Math.sign = Math.sign || function(x) {
  x = +x; // convert to a number
  if (x === 0 || isNaN(x)) {
    return x;
  }
  return x > 0 ? 1 : -1;
};
</pre>
						</p>
						<h3>6.3 Math.cbrt()</h3>
						<p>
<span>Math.cbrt方法用于计算一个数的立方根。</span>
<pre>
Math.cbrt(-1) // -1
Math.cbrt(0)  // 0
Math.cbrt(1)  // 1
Math.cbrt(2)  // 1.2599210498948734
</pre>
<span>对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。</span>
<pre>
Math.cbrt('8') // 2
Math.cbrt('hello') // NaN
</pre>
<span>对于没有部署这个方法的环境，可以用下面的代码模拟。</span>
<pre>
Math.cbrt = Math.cbrt || function(x) {
  var y = Math.pow(Math.abs(x), 1/3);
  return x < 0 ? -y : y;
};
</pre>
						</p>
						<h3>6.4 Math.clz32()</h3>
						<p>
<span>JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。</span>
<pre>
Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1000) // 22
Math.clz32(0b01000000000000000000000000000000) // 1
Math.clz32(0b00100000000000000000000000000000) // 2
</pre>
<span>上面代码中，0的二进制形式全为0，所以有32个前导0；1的二进制形式是0b1，只占1位，所以32位之中有31个前导0；1000的二进制形式是0b1111101000，一共有10位，所以32位之中有22个前导0。</span>
<span>左移运算符（<<）与Math.clz32方法直接相关。</span>
<pre>
Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1 << 1) // 30
Math.clz32(1 << 2) // 29
Math.clz32(1 << 29) // 2
</pre>
<span>对于小数，Math.clz32方法只考虑整数部分。</span>
<pre>
Math.clz32(3.2) // 30
Math.clz32(3.9) // 30
</pre>
<span>对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。</span>
<pre>
Math.clz32() // 32
Math.clz32(NaN) // 32
Math.clz32(Infinity) // 32
Math.clz32(null) // 32
Math.clz32('foo') // 32
Math.clz32([]) // 32
Math.clz32({}) // 32
Math.clz32(true) // 31
</pre>
						</p>
						<h3>6.5 Math.imul() </h3>
						<p>
<span>Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</span>
<pre>
Math.imul(2, 4)   // 8
Math.imul(-1, 8)  // -8
Math.imul(-2, -2) // 4
</pre>
<span>如果只考虑最后32位，大多数情况下，Math.imul(a, b)与a * b的结果是相同的，即该方法等同于(a * b)|0的效果（超过32位的部分溢出）。之所以需要部署这个方法，是因为JavaScript有精度限制，超过2的53次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。</span>
<pre>
(0x7fffffff * 0x7fffffff)|0 // 0
</pre>
<span>上面这个乘法算式，返回结果为0。但是由于这两个二进制数的最低位都是1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是1。这个错误就是因为它们的乘积超过了2的53次方，JavaScript无法保存额外的精度，就把低位的值都变成了0。Math.imul方法可以返回正确的值1。</span>
<pre>
Math.imul(0x7fffffff, 0x7fffffff) // 1
</pre>
						</p>
						<h3>6.6 Math.fround() </h3>
						<p>
<span>Math.fround方法返回一个数的单精度浮点数形式。</span>
<pre>
Math.fround(0)     // 0
Math.fround(1)     // 1
Math.fround(1.337) // 1.3370000123977661
Math.fround(1.5)   // 1.5
Math.fround(NaN)   // NaN
</pre>
<span>对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个小数的单精度浮点数。</span>
<span>对于没有部署这个方法的环境，可以用下面的代码模拟。</span>
<pre>
Math.fround = Math.fround || function(x) {
  return new Float32Array([x])[0];
};
</pre>
						</p>
						<h3>6.7 Math.hypot() </h3>
						<p>
<span>Math.hypot方法返回所有参数的平方和的平方根。</span>
<pre>
Math.hypot(3, 4);        // 5
Math.hypot(3, 4, 5);     // 7.0710678118654755
Math.hypot();            // 0
Math.hypot(NaN);         // NaN
Math.hypot(3, 4, 'foo'); // NaN
Math.hypot(3, 4, '5');   // 7.0710678118654755
Math.hypot(-3);          // 3	
</pre>
<span>如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。</span>
						</p>
						<h3>6.8 Math.expm1() </h3>
						<p>
<span>Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。</span>
<pre>
Math.expm1(-1) // -0.6321205588285577
Math.expm1(0)  // 0
Math.expm1(1)  // 1.718281828459045
</pre>
<span>对于没有部署这个方法的环境，可以用下面的代码模拟。</span>
<pre>
Math.expm1 = Math.expm1 || function(x) {
  return Math.exp(x) - 1;
};
</pre>
						</p>
						<h3>6.9 Math.log1p() </h3>
						<p>
<span>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</span>
<pre>
Math.log1p(1)  // 0.6931471805599453
Math.log1p(0)  // 0
Math.log1p(-1) // -Infinity
Math.log1p(-2) // NaN
</pre>
<span>对于没有部署这个方法的环境，可以用下面的代码模拟。</span>
<pre>
Math.log1p = Math.log1p || function(x) {
  return Math.log(1 + x);
};
</pre>
						</p>
						<h3>6.10 Math.log10() </h3>
						<p>
<span>Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。</span>
<pre>
Math.log10(2)      // 0.3010299956639812
Math.log10(1)      // 0
Math.log10(0)      // -Infinity
Math.log10(-2)     // NaN
Math.log10(100000) // 5
</pre>
<span>对于没有部署这个方法的环境，可以用下面的代码模拟。</span>
<pre>
Math.log10 = Math.log10 || function(x) {
  return Math.log(x) / Math.LN10;
};
</pre>
						</p>
						<h3>6.11 Math.log2() </h3>
						<p>
<span>Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。</span>
<pre>
Math.log2(3)       // 1.584962500721156
Math.log2(2)       // 1
Math.log2(1)       // 0
Math.log2(0)       // -Infinity
Math.log2(-2)      // NaN
Math.log2(1024)    // 10
Math.log2(1 << 29) // 29
</pre>
<span>对于没有部署这个方法的环境，可以用下面的代码模拟。</span>
<pre>
Math.log2 = Math.log2 || function(x) {
  return Math.log(x) / Math.LN2;
};
</pre>
						</p>
						<h3>6.12 三角函数方法 </h3>
						<p>
<span>ES6新增了6个三角函数方法。</span>
<span>Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）<br>
Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）<br>
Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）<br>
Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）<br>
Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）<br>
Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</span>
						</p>
						<h3>6.3 指数运算符</h3>
						<p>
<span>ES2016 新增了一个指数运算符（**）。</span>
<pre>
2 ** 2 // 4
2 ** 3 // 8
</pre>
<span>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。</span>
<pre>
let a = 2;
a **= 2;
// 等同于 a = a * a;

let b = 3;
b **= 3;
// 等同于 b = b * b * b;
</pre>
<span>注意，在 V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。</span>
<pre>
Math.pow(99, 99)
// 3.697296376497263e+197

99 ** 99
// 3.697296376497268e+197
</pre>
<span>上面代码中，两个运算结果的最后一位有效数字是有差异的。</span>
						</p>
						<h2>7 数组的扩展 </h2>
						<h3>7.1 Array.from()  </h3>
						<p>
<span>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</span>
<span>下面是一个类似数组的对象，Array.from将它转为真正的数组。</span>
<pre>
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
</pre>
<span>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</span>
<pre>
// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).forEach(function (p) {
  console.log(p);
});

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}
</pre>
<span>上面代码中，querySelectorAll方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用forEach方法。</span>
<span>只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。</span>
<pre>
Array.from('hello')
// ['h', 'e', 'l', 'l', 'o']

let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
</pre>
<span>上面代码中，字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。</span>
<span>如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。</span>
<pre>
Array.from([1, 2, 3])
// [1, 2, 3]
</pre>
<span>值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。</span>
<pre>
// arguments对象
function foo() {
  var args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll('div')]
</pre>
<span>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</span>
<pre>
Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
</pre>
<span>上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。</span>
<span>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。</span>
<pre>
const toArray = (() =>
  Array.from ? Array.from : obj => [].slice.call(obj)
)();
</pre>
<span>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</span>
<pre>
Array.from(arrayLike, x => x * x);
// 等同于
Array.from(arrayLike).map(x => x * x);

Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
</pre>
<span>下面的例子是取出一组DOM节点的文本内容。</span>
<pre>
let spans = document.querySelectorAll('span.name');

// map()
let names1 = Array.prototype.map.call(spans, s => s.textContent);

// Array.from()
let names2 = Array.from(spans, s => s.textContent)
</pre>
<span>下面的例子将数组中布尔值为false的成员转为0。</span>
<pre>
Array.from([1, , 2, , 3], (n) => n || 0)
// [1, 0, 2, 0, 3]
</pre>
<span>另一个例子是返回各种数据的类型。</span>
<pre>
function typesOf () {
  return Array.from(arguments, value => typeof value)
}
typesOf(null, [], NaN)
// ['object', 'object', 'number']
</pre>
<span>如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。</span>
<span>Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</span>
<pre>
Array.from({ length: 2 }, () => 'jack')
// ['jack', 'jack']
</pre>
<span>上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</span>
<span>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。</span>
<pre>
function countSymbols(string) {
  return Array.from(string).length;
}
</pre>
						</p>
						<h3>7.2 Array.of()</h3>
						<p>
<span>Array.of方法用于将一组值，转换为数组。</span>						
<pre>
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
</pre>
<span>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。</span>
<pre>
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
</pre>
<span>上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</span>
<span>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</span>
<pre>
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
</pre>
<span>Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</span>
<span>Array.of方法可以用下面的代码模拟实现。</span>
<pre>
function ArrayOf(){
  return [].slice.call(arguments);
}
</pre>
						</p>
						<h3>7.3 数组实例的copyWithin()</h3>
						<p>
<span>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</span>						
<pre>
Array.prototype.copyWithin(target, start = 0, end = this.length)
</pre>
<span>它接受三个参数:<br>
-target（必需）：从该位置开始替换数据。<br>
-start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>
-end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</span>
<span>这三个参数都应该是数值，如果不是，会自动转为数值。</span>
<pre>
[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
</pre>
<span>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</span>
<pre>
// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3)
// {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
var i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署TypedArray的copyWithin方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]
</pre>
						</p>
						<h3>7.4 数组实例的find()和findIndex()</h3>
						<p>
<span>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</span>	
<pre>
[1, 4, -5, 10].find((n) => n < 0)
// -5

[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}) // 10
</pre>
<span>上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</span>
<span>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</span>
<pre>
[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
}) // 2
</pre>
<span>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</span>
<pre>
[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y => Object.is(NaN, y))
// 0
</pre>
<span>上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。</span>
						</p>
						<h3>7.5 数组实例的fill()</h3>
						<p>
<span>fill方法使用给定值，填充一个数组</span>						
<pre>
['a', 'b', 'c'].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</pre>
<span>上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</span>
<span>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</span>
<pre>
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
</pre>
						</p>
						<h3>7.6 数组实例的entries()，keys()和values() </h3>
						<p>
<span>ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</span>						
<pre>
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
</pre>
<span>如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。</span>
<pre>
let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']
</pre>
						</p>
						<h3>7.7 数组实例的includes()</h3>
						<p>
<span>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。</span>						
<pre>
[1, 2, 3].includes(2);     // true
[1, 2, 3].includes(4);     // false
[1, 2, NaN].includes(NaN); // true
</pre>
<span>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</span>
<pre>
[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</pre>
<span>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。</span>
<span>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对NaN的误判。</span>
<pre>
[NaN].indexOf(NaN)
// -1
</pre>
<span>includes使用的是不一样的判断算法，就没有这个问题。</span>
<pre>
[NaN].includes(NaN)
// true
</pre>
<span>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</span>
<pre>
const contains = (() =>
  Array.prototype.includes
    ? (arr, value) => arr.includes(value)
    : (arr, value) => arr.some(el => el === value)
)();
contains(["foo", "bar"], "baz"); // => false
</pre>
<span>另外，Map和Set数据结构有一个has方法，需要注意与includes区分。<br>
Map结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。<br>
Set结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。</span>
						</p>
						<h3>7.8 数组的空位</h3>
						<p>
<span>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。</span>						
<pre>
Array(3) // [, , ,]
</pre>
<span>注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。</span>
<pre>
0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
</pre>
<span>上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</span>
<pre>
// forEach方法
[,'a'].forEach((x,i) => console.log(i)); // 1

// filter方法
['a',,'b'].filter(x => true) // ['a','b']

// every方法
[,'a'].every(x => x==='a') // true

// some方法
[,'a'].some(x => x !== 'a') // false

// map方法
[,'a'].map(x => 1) // [,1]

// join方法
[,'a',undefined,null].join('#') // "#a##"

// toString方法
[,'a',undefined,null].toString() // ",a,,"
</pre>
<span>ES6则是明确将空位转为undefined。</span>
<span>Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</span>
<pre>
Array.from(['a',,'b'])
// [ "a", undefined, "b" ]
</pre>
<span>扩展运算符（...）也会将空位转为undefined。</span>
<pre>
[...['a',,'b']]
// [ "a", undefined, "b" ]
</pre>
<span>copyWithin()会连空位一起拷贝。</span>
<pre>
[,'a','b',,].copyWithin(2,0) // [,"a",,"a"]
</pre>
<span>fill()会将空位视为正常的数组位置。</span>
<pre>
new Array(3).fill('a') // ["a","a","a"]
</pre>
<span>for...of循环也会遍历空位。</span>
<pre>
let arr = [, ,];
for (let i of arr) {
  console.log(1);
}
// 1
// 1
</pre>
<span>上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。</span>
<span>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</span>
<pre>
// entries()
[...[,'a'].entries()] // [[0,undefined], [1,"a"]]

// keys()
[...[,'a'].keys()] // [0,1]

// values()
[...[,'a'].values()] // [undefined,"a"]

// find()
[,'a'].find(x => true) // undefined

// findIndex()
[,'a'].findIndex(x => true) // 0
</pre>
						</p>
						<h2>8 函数的扩展</h2>
						<h3>8.1 函数参数的默认值</h3>
						<p>
<span>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</span>
<pre>
function log(x, y) {
  y = y || 'World';
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello World
</pre>
<span>上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。</span>
<span>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</span>
<pre>
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
</pre>
<span>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。</span>
<pre>
function Point(x = 0, y = 0) {
  this.x = x;
  this.y = y;
}

var p = new Point();
p // { x: 0, y: 0 }
</pre>
<span>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</span>
<span>参数变量是默认声明的，所以不能用let或const再次声明。</span>
<pre>
function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
</pre>
<span>使用参数默认值时，函数不能有同名参数。</span>
<pre>
function foo(x, x, y = 1) {
  // ...
}
// SyntaxError: Duplicate parameter name not allowed in this context
</pre>
<span>另外，一个容易忽略的地方是，如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</span>
<pre>
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101
</pre>
<span>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</span>
						</p>
						<h4>8.1.1 与解构赋值默认值结合使用</h4>
						<p>
<span>参数默认值可以与解构赋值的默认值，结合起来使用。</span>
<pre>
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined, 5
foo({x: 1}) // 1, 5
foo({x: 1, y: 2}) // 1, 2
foo() // TypeError: Cannot read property 'x' of undefined
</pre>
<span>上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量x和y就不会生成，从而报错。如果参数对象没有y属性，y的默认值5才会生效。</span>
<pre>
function fetch(url, { body = '', method = 'GET', headers = {} }) {
  console.log(method);
}

fetch('http://example.com', {})
// "GET"

fetch('http://example.com')
// 报错
</pre>
<span>上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。</span>
<span>上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</span>
<pre>
function fetch(url, { method = 'GET' } = {}) {
  console.log(method);
}

fetch('http://example.com')
// "GET"
</pre>
<span>上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。</span>
<pre>
// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
</pre>
<span>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</span>
<pre>
// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x和y都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x有值，y无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x和y都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
</pre>
						</p>
						<h4>8.1.2 参数默认值的位置</h4>
						<p>
<span>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</span>
<pre>
// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) {
  return [x, y, z];
}

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
</pre>
<span>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。</span>
<span>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</span>
<pre>
function foo(x = 5, y = 6) {
  console.log(x, y);
}

foo(undefined, null)
// 5 null
</pre>
						</p>
						<h4>8.1.3 函数的 length 属性 </h4>
						<p>
<span>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</span>
<pre>
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
</pre>
<span>上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了3个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2</span>
<span>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入length属性。</span>
<pre>
(function(...args) {}).length // 0
</pre>
<span>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</span>
<pre>
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
</pre>

						</p>
						<h4>8.1.4 作用域</h4>
						<p>
<span>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</span>
<pre>
var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2
</pre>
<span>上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。</span>
<pre>
let x = 1;

function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // 1
</pre>
<span>上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。</span>
<span>如果此时，全局变量x不存在，就会报错。</span>
<pre>
function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // ReferenceError: x is not defined
</pre>
<span>上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</span>
<span>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</span>
<pre style="color:#008B8B">
let foo = 'outer';

function bar(func = x => foo) {
  let foo = 'inner';
  console.log(func()); // outer
}

bar();
</pre>
<span>上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。</span>
<span>如果写成下面这样，就会报错。</span>
<pre style="color:#ff3366">
function bar(func = () => foo) {
  let foo = 'inner';
  console.log(func());
}

bar() // ReferenceError: foo is not defined
</pre>
<span>上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。</span>
<pre>
var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;
  y();
  console.log(x);
}

foo() // 3
x // 1
</pre>
<span>上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。</span>
<span>如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。</span>
<pre style="color:#ff3366">
var x = 1;
function foo(x, y = function() { x = 2; }) {
  x = 3;
  y();
  console.log(x);
}

foo() // 2
x // 1
</pre>
						</p>
						<h4>8.1.5 应用 </h4>
						<p>
<span>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</span>
<pre>
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter
</pre>
<span>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。</span>
<span>从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（即函数名之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行（即如果参数已经赋值，默认值中的函数就不会运行），这与 Python 语言不一样。</span>
<span>另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。</span>
<pre>
function foo(optional = undefined) { ··· }
</pre>
						</p>
						<h3>8.2 rest参数</h3>
						<p>
<span>ES6 引入 rest 参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</span>
<pre>
function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
</pre>
<span>上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</span>
<span>下面是一个 rest 参数代替arguments变量的例子。</span>
<pre>
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
</pre>
<span>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</span>
<span>rest 参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用 rest 参数改写数组push方法的例子。</span>
<pre>
function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
    console.log(item);
  });
}

var a = [];
push(a, 1, 2, 3)
</pre>
<span>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</span>
<pre>
// 报错
function f(a, ...b, c) {
  // ...
}
</pre>
<span>函数的length属性，不包括 rest 参数。</span>
<pre>
(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
</pre>
						</p>
						<h3>8.3 扩展运算符</h3>
						<h4>8.3.1 含义</h4>
						<p>
<span>扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</span>
<pre>
console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll('div')]
// [<div>, <div>, <div>]
</pre>
<span>该运算符主要用于函数调用。</span>
<pre>
function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

var numbers = [4, 38];
add(...numbers) // 42
</pre>
<span>上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</span>
<pre>
function f(v, w, x, y, z) { }
var args = [0, 1];
f(-1, ...args, 2, ...[3]);
</pre>
						</p>
						<h4>8.3.2 替代数组的apply方法</h4>
						<p>
<span>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</span>
<pre>
// ES5的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f(...args);
</pre>
<span>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</span>
<pre>
// ES5的写法
Math.max.apply(null, [14, 3, 77])

// ES6的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
</pre>
<span>上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</span>
<span>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。</span>
<pre>
// ES5的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);

// ES6的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1.push(...arr2);
</pre>
<span>上面代码的ES5写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</span>
<pre>
// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
</pre>
						</p>
						<h4>8.3.3 扩展运算符的应用</h4>
						<p>
<span>（1）合并数组</span>
<span>扩展运算符提供了数组合并的新写法。</span>
<pre>
// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]

var arr1 = ['a', 'b'];
var arr2 = ['c'];
var arr3 = ['d', 'e'];

// ES5的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]

// ES6的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]
</pre>
<span>（2）与解构赋值结合</span>
<span>扩展运算符可以与解构赋值结合起来，用于生成数组。</span>
<pre>
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list

const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []:

const [first, ...rest] = ["foo"];
first  // "foo"
rest   // []
</pre>
<span>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</span>
<pre>
const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</pre>
<span>（3）函数的返回值</span>
<span>JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</span>
<pre>
var dateFields = readDateFields(database);
var d = new Date(...dateFields);
</pre>
<span>上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。</span>
<span>（4）字符串</span>
<span>扩展运算符还可以将字符串转为真正的数组。</span>
<pre>
[...'hello']
// [ "h", "e", "l", "l", "o" ]
</pre>
<span>上面的写法，有一个重要的好处，那就是能够正确识别32位的Unicode字符。</span>
<pre>
'x\uD83D\uDE80y'.length // 4
[...'x\uD83D\uDE80y'].length // 3
</pre>
<span>上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</span>
<pre>
function length(str) {
  return [...str].length;
}

length('x\uD83D\uDE80y') // 3
</pre>
<span>凡是涉及到操作32位Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</span>
<pre>
let str = 'x\uD83D\uDE80y';

str.split('').reverse().join('')
// 'y\uDE80\uD83Dx'

[...str].reverse().join('')
// 'y\uD83D\uDE80x'
</pre>
<span>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</span>
<span>（5）实现了Iterator接口的对象</span>
<span>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</span>
<pre>
var nodeList = document.querySelectorAll('div');
var array = [...nodeList];
</pre>
<span>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator接口。</span>
<span>对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</span>
<pre>
let arrayLike = {
  '0': 'a',
  '1': 'b',
  '2': 'c',
  length: 3
};

// TypeError: Cannot spread non-iterable object.
let arr = [...arrayLike];
</pre>
<span style="color:#ff3366">上面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</span>
<span>（6）Map和Set结构，Generator函数</span>
<span>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</span>
<pre>
let map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

let arr = [...map.keys()]; // [1, 2, 3]
</pre>
<span>Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符</span>
<pre>
var go = function*(){
  yield 1;
  yield 2;
  yield 3;
};

[...go()] // [1, 2, 3]
</pre>
<span>上面代码中，变量go是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</span>
<span style="color:#ff3366">如果对没有iterator接口的对象，使用扩展运算符，将会报错</span>
<pre>
var obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
</pre>
						</p>
						<h3>8.4 严格模式 </h3>
						<p>
<span>从ES5开始，函数内部可以设定为严格模式。</span>
<pre>
function doSomething(a, b) {
  'use strict';
  // code
}
</pre>
<span>《ECMAScript 2016标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</span>
<pre>
// 报错
function doSomething(a, b = a) {
  'use strict';
  // code
}

// 报错
const doSomething = function ({a, b}) {
  'use strict';
  // code
};

// 报错
const doSomething = (...a) => {
  'use strict';
  // code
};

const obj = {
  // 报错
  doSomething({a, b}) {
    'use strict';
    // code
  }
};
</pre>
<span>这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</span>
<pre>
// 报错
function doSomething(value = 070) {
  'use strict';
  return value;
}
</pre>
<span>上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</span>
<span>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</span>
<span>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</span>
<pre>
'use strict';

function doSomething(a, b = a) {
  // code
}
</pre>
<span>第二种是把函数包在一个无参数的立即执行函数里面。</span>
<pre>
const doSomething = (function () {
  'use strict';
  return function(value = 42) {
    return value;
  };
}());
</pre>
						</p>
						<h3>8.5 name 属性</h3>
						<p>
<span>函数的name属性，返回该函数的函数名。</span>
<pre>
function foo() {}
foo.name // "foo"
</pre>
<span>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</span>
<span>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。</span>
<pre>
var f = function () {};

// ES5
f.name // ""

// ES6
f.name // "f"
</pre>
<span>上面代码中，变量f等于一个匿名函数，ES5 和 ES6 的name属性返回的值不一样。如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。</span>
<pre>
const bar = function baz() {};

// ES5
bar.name // "baz"

// ES6
bar.name // "baz"
</pre>
<span>Function构造函数返回的函数实例，name属性的值为anonymous。</span>
<pre>
(new Function).name // "anonymous"
</pre>
<span>bind返回的函数，name属性值会加上bound前缀。</span>
<pre>
function foo() {};
foo.bind({}).name // "bound foo"

(function(){}).bind({}).name // "bound "
</pre>
						</p>
						<h3>8.6 箭头函数 </h3>
						<h4>8.6.1 基本用法</h4>
						<p>
<span>ES6允许使用“箭头”（=>）定义函数。</span>
<pre>
var f = v => v;
</pre>
<span>上面的箭头函数等同于：</span>
<pre>
var f = function(v) {
  return v;
};
</pre>
<span>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</span>
<pre>
var f = () => 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) => num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};
</pre>
<span>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</span>
<pre>
var sum = (num1, num2) => { return num1 + num2; }
</pre>
<span style="color:#ff3366">由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</span>
<pre>
var getTempItem = id => ({ id: id, name: "Temp" });
</pre>
<span>箭头函数可以与变量解构结合使用。</span>
<pre>
const full = ({ first, last }) => first + ' ' + last;

// 等同于
function full(person) {
  return person.first + ' ' + person.last;
}
</pre>
<span>箭头函数使得表达更加简洁。</span>
<pre>
const isEven = n => n % 2 == 0;
const square = n => n * n;
</pre>
<span>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</span>
<span>箭头函数的一个用处是简化回调函数。</span>
<pre>
// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x => x * x);


// 正常函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) => a - b);
</pre>
<span>下面是rest参数与箭头函数结合的例子。</span>
<pre>
const numbers = (...nums) => nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) => [head, tail];

headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
</pre>
						</p>
						<h4>8.6.2 使用注意点</h4>
						<p>
<span style="color:#ff3366">箭头函数有几个使用注意点。</span>
<span style="color:#ff3366">
（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>
（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>
（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。<br>
（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。<br>
上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。
</span>
<pre>
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
// id: 42
</pre>
<span>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。</span>
<span>箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</span>
<pre>
function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() => this.s1++, 1000);
  // 普通函数
  setInterval(function () {
    this.s2++;
  }, 1000);
}

var timer = new Timer();

setTimeout(() => console.log('s1: ', timer.s1), 3100);
setTimeout(() => console.log('s2: ', timer.s2), 3100);
// s1: 3
// s2: 0
</pre>
<span style="color:#ff3366">上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。</span>
<span>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</span>
<pre>
var handler = {
  id: '123456',

  init: function() {
    document.addEventListener('click',
      event => this.doSomething(event.type), false);
  },

  doSomething: function(type) {
    console.log('Handling ' + type  + ' for ' + this.id);
  }
};	
</pre>
<span>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</span>
<span>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</span>
<pre>
// ES6
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;

  setTimeout(function () {
    console.log('id:', _this.id);
  }, 100);
}
</pre>
<span>上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。</span>
<pre>
function foo() {
  return () => {
    return () => {
      return () => {
        console.log('id:', this.id);
      };
    };
  };
}

var f = foo.call({id: 1});

var t1 = f.call({id: 2})()(); // id: 1
var t2 = f().call({id: 3})(); // id: 1
var t3 = f()().call({id: 4}); // id: 1
</pre>
<span>上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。</span>
<span>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</span>
<pre>
function foo() {
  setTimeout(() => {
    console.log('args:', arguments);
  }, 100);
}

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]
</pre>
<span>上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。</span>
<span>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</span>
<pre>
(function() {
  return [
    (() => this.x).bind({ x: 'inner' })()
  ];
}).call({ x: 'outer' });
</pre>
						</p>
						<h4>8.6.3 嵌套的箭头函数</h4>
						<p>
<span>箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。</span>
<pre>
function insert(value) {
  return {into: function (array) {
    return {after: function (afterValue) {
      array.splice(array.indexOf(afterValue) + 1, 0, value);
      return array;
    }};
  }};
}

insert(2).into([1, 3]).after(1); //[1, 2, 3]
</pre>
<span>上面这个函数，可以使用箭头函数改写。</span>
<pre>
let insert = (value) => ({into: (array) => ({after: (afterValue) => {
  array.splice(array.indexOf(afterValue) + 1, 0, value);
  return array;
}})});

insert(2).into([1, 3]).after(1); //[1, 2, 3]
</pre>
<span>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</span>
						</p>
						<h3>8.7 尾调用优化</h3>
						<h4>8.7.1 什么是尾调用？</h4>
						<p>
<span>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</span>
<pre>
function f(x){
  return g(x);
}
</pre>
<span>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</span>
<span>以下三种情况，都不属于尾调用。</span>
<pre>
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
}
</pre>
<span>上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</span>
<pre>
function f(x){
  g(x);
  return undefined;
}
</pre>
<span>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</span>
<pre>
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
</pre>
<span>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</span>
						</p>
						<h4>8.7.2 尾调用优化</h4>
						<p>
<span>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</span>
<span>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</span>
<span>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</span>
<pre>
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
</pre>
<span>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</span>
<span>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</span>
<span>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</span>
<pre>
function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}
</pre>
<span>上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。</span>
						</p>
						<h4>8.7.3 尾递归 </h4>
						<p>
<span>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</span>
<span>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</span>
<pre>
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
</pre>
<span>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</span>
<span>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</span>
<pre>
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
</pre>
<span>还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性</span>
<span>如果是非尾递归的fibonacci 递归方法</span>
<pre>
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10); // 89
// Fibonacci(100)
// Fibonacci(500)
// 堆栈溢出了
</pre>
<span>如果我们使用尾递归优化过的fibonacci 递归算法</span>
<pre>
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
</pre>
						</p>
						<h4>8.7.4 递归函数的改写</h4>
						<p>
<span>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</span>
<span>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</span>
<pre>
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

function factorial(n) {
  return tailFactorial(n, 1);
}

factorial(5) // 120
</pre>
<span>上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。</span>
<span style="color:#ff3366">函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</span>
<pre>
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
</pre>
<span>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。</span>
<span>第二种方法就简单多了，就是采用ES6的函数默认值。</span>
<pre>
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
</pre>
<span>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</span>
						</p>
						<h4>8.7.5 严格模式</h4>
						<p>
<span style="color:#ff3366">ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</span>
<span>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。<br>
func.arguments：返回调用时函数的参数。<br>
func.caller：返回调用当前函数的那个函数。</span>
<span>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</span>
<pre>
function restricted() {
  "use strict";
  restricted.caller;    // 报错
  restricted.arguments; // 报错
}
restricted();
</pre>
						</p>
						<h4>8.7.6 尾递归优化的实现</h4>
						<p>
<span>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</span>
<span>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</span>
<pre>
function sum(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1);
  } else {
    return x;
  }
}

sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)
</pre>
<span>上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归100000次，就会报错，提示超出调用栈的最大次数。</span>
<span>蹦床函数（trampoline）可以将递归执行转为循环执行。</span>
<pre>
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}
</pre>
<span>上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</span>
<span>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</span>
<pre>
function sum(x, y) {
  if (y > 0) {
    return sum.bind(null, x + 1, y - 1);
  } else {
    return x;
  }
}
</pre>
<span>上面代码中，sum函数的每次执行，都会返回自身的另一个版本。</span>
<span>现在，使用蹦床函数执行sum，就不会发生调用栈溢出。</span>
<pre>
trampoline(sum(1, 100000))
// 100001
</pre>
<span>蹦床函数并不是真正的尾递归优化，下面的实现才是。</span>
<pre>
function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco(function(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});

sum(1, 100000)
// 100001
</pre>
<span>上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层</span>
						</p>
						<h3>8.8 函数参数的尾逗号</h3>
						<p>
<span>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</span>
<pre>
function clownsEverywhere(
  param1,
  param2
) { /* ... */ }

clownsEverywhere(
  'foo',
  'bar'
);
</pre>
<span>上面代码中，如果在param2或bar后面加一个逗号，就会报错。</span>
<span>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</span>
<pre>
function clownsEverywhere(
  param1,
  param2,
) { /* ... */ }

clownsEverywhere(
  'foo',
  'bar',
);
</pre>
						</p>
						<h2>9 对象的扩展</h2>
						<h3>9.1 属性的简洁表示法 </h3>
						<p>
<span>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</span>
<pre>
var foo = 'bar';
var baz = {foo};
baz // {foo: "bar"}

// 等同于
var baz = {foo: foo};
</pre>
<span>上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。</span>
<pre>
function f(x, y) {
  return {x, y};
}

// 等同于

function f(x, y) {
  return {x: x, y: y};
}

f(1, 2) // Object {x: 1, y: 2}
</pre>
<span>除了属性简写，方法也可以简写。</span>
<pre>
var o = {
  method() {
    return "Hello!";
  }
};

// 等同于

var o = {
  method: function() {
    return "Hello!";
  }
};
</pre>
<span>下面是一个实际的例子。</span>
<pre>
var birth = '2000/01/01';

var Person = {

  name: '张三',

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() { console.log('我的名字是', this.name); }

};
</pre>
<span>这种写法用于函数的返回值，将会非常方便。</span>
<pre>
function getPoint() {
  var x = 1;
  var y = 10;
  return {x, y};
}

getPoint()
// {x:1, y:10}
</pre>
<span>CommonJS模块输出变量，就非常合适使用简洁写法。</span>
<pre>
var ms = {};

function getItem (key) {
  return key in ms ? ms[key] : null;
}

function setItem (key, value) {
  ms[key] = value;
}

function clear () {
  ms = {};
}

module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};
</pre>
<span>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</span>
<pre>
var cart = {
  _wheels: 4,

  get wheels () {
    return this._wheels;
  },

  set wheels (value) {
    if (value < this._wheels) {
      throw new Error('数值太小了！');
    }
    this._wheels = value;
  }
}
</pre>
<span>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</span>
<pre>
var obj = {
  class () {}
};

// 等同于

var obj = {
  'class': function() {}
};
</pre>
<span>上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。</span>
<span>如果某个方法的值是一个Generator函数，前面需要加上星号。</span>
<pre>
var obj = {
  * m(){
    yield 'hello world';
  }
};
</pre>
						</p>
						<h3>9.2 属性名表达式 </h3>
						<p>
<span>JavaScript语言定义对象的属性，有两种方法。</span>
<pre>
// 方法一
obj.foo = true;

// 方法二
obj['a' + 'bc'] = 123;
</pre>
<span>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内</span>
<span>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</span>
<pre>
var obj = {
  foo: true,
  abc: 123
};
</pre>
<span>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</span>
<pre>
let propKey = 'foo';

let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
};


var lastWord = 'last word';

var a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"
</pre>
<span>表达式还可以用于定义方法名。</span>
<pre>
let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};

obj.hello() // hi
</pre>
<span>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</span>
<pre>
// 报错
var foo = 'bar';
var bar = 'abc';
var baz = { [foo] };

// 正确
var foo = 'bar';
var baz = { [foo]: 'abc'};
</pre>
<span>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。</span>
<pre>
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}
</pre>
<span>上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。</span>
						</p>
						<h3>9.3 方法的 name 属性</h3>
						<p>
<span>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</span>
<pre>
const person = {
  sayName() {
    console.log('hello!');
  },
};
person.sayName.name   // "sayName"
</pre>
<span>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。</span>
<pre>
const obj = {
  get foo() {},
  set foo(x) {}
};

obj.foo.name
// TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

descriptor.get.name // "get foo"
descriptor.set.name // "set foo"
</pre>
<span style="color:#ff3366">有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。</span>
<pre>
(new Function()).name // "anonymous"

var doSomething = function() {
  // ...
};
doSomething.bind().name // "bound doSomething"
</pre>
<span>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</span>
<pre>
const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // "[description]"
obj[key2].name // ""
</pre>
						</p>
						<h3>9.4 Object.is() </h3>
						<p>
<span>ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</span>
<span>ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</span>
<pre>
Object.is('foo', 'foo')
// true
Object.is({}, {})
// false
</pre>
<span>不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</span>
<pre>
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</pre>
<span>ES5可以通过下面的代码，部署Object.is。</span>
<pre>
Object.defineProperty(Object, 'is', {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x && y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});
</pre>
						</p>
						<h3>9.5 Object.assign()</h3>
						<h4>9.5.1 基本用法</h4>
						<p>
<span>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</span>
<pre>
var target = { a: 1 };

var source1 = { b: 2 };
var source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</pre>
<span>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</span>
<pre>
var target = { a: 1, b: 1 };

var source1 = { b: 2, c: 2 };
var source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</pre>
<span>如果只有一个参数，Object.assign会直接返回该参数</span>
<pre>
var obj = {a: 1};
Object.assign(obj) === obj // true
</pre>
<span>如果该参数不是对象，则会先转成对象，然后返回。</span>
<pre>
typeof Object.assign(2) // "object"
</pre>
<span style="color:#ff3366">由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。</span>
<pre>
Object.assign(undefined) // 报错
Object.assign(null) // 报错
</pre>
<span>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。</span>
<pre>
let obj = {a: 1};
Object.assign(obj, undefined) === obj // true
Object.assign(obj, null) === obj // true
</pre>
<span>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</span>
<pre>
var v1 = 'abc';
var v2 = true;
var v3 = 10;

var obj = Object.assign({}, v1, v2, v3);
console.log(obj); // { "0": "a", "1": "b", "2": "c" }
</pre>
<span>上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</span>
<pre>
Object(true) // {[[PrimitiveValue]]: true}
Object(10)  //  {[[PrimitiveValue]]: 10}
Object('abc') // {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}
</pre>
<span>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</span>
<span>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</span>
<pre>
Object.assign({b: 'c'},
  Object.defineProperty({}, 'invisible', {
    enumerable: false,
    value: 'hello'
  })
)
// { b: 'c' }
</pre>
<span>上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。</span>
<span>属性名为Symbol值的属性，也会被Object.assign拷贝。</span>
<pre>
Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' })
// { a: 'b', Symbol(c): 'd' }
</pre>
						</p>
						<h4>9.5.2 注意点</h4>
						<p>
<span>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</span>
<pre>
var obj1 = {a: {b: 1}};
var obj2 = Object.assign({}, obj1);

obj1.a.b = 2;
obj2.a.b // 2
</pre>
<span>上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</span>
<span>对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。</span>
<pre>
var target = { a: { b: 'c', d: 'e' } }
var source = { a: { b: 'hello' } }
Object.assign(target, source)
// { a: { b: 'hello' } }
</pre>
<span>上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: 'hello', d: 'e' } }的结果。这通常不是开发者想要的，需要特别小心。</span>
<span>有一些函数库提供Object.assign的定制版本（比如Lodash的_.defaultsDeep方法），可以解决浅拷贝的问题，得到深拷贝的合并。</span>
<span>注意，Object.assign可以用来处理数组，但是会把数组视为对象。</span>
<pre>
Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3]
</pre>
<span>上面代码中，Object.assign把数组视为属性名为0、1、2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1。</span>
						</p>
						<h4>9.5.3 常见用途</h4>
						<p>
<span>（1）为对象添加属性</span>
<pre>
class Point {
  constructor(x, y) {
    Object.assign(this, {x, y});
  }
}
</pre>
<span>上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。</span>
<span>（2）为对象添加方法</span>
<pre>
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
</pre>
<span>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。</span>
<span>（3）克隆对象</span>
<pre>
function clone(origin) {
  return Object.assign({}, origin);
}
</pre>
<span>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</span>
<span>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</span>
<span>（4）合并多个对象</span>
<span>将多个对象合并到某个对象。</span>
<pre>
const merge = (target, ...sources) => Object.assign(target, ...sources);
</pre>
<span>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</span>
<pre>
const merge = (...sources) => Object.assign({}, ...sources);
</pre>
<span>（5）为属性指定默认值</span>
<pre>
const DEFAULTS = {
  logLevel: 0,
  outputFormat: 'html'
};

function processContent(options) {
  options = Object.assign({}, DEFAULTS, options);
  console.log(options);
  // ...
}
</pre>
<span>上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。</span>
<span style="color:#ff3366">注意，由于存在深拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。</span>
<pre>
const DEFAULTS = {
  url: {
    host: 'example.com',
    port: 7070
  },
};

processContent({ url: {port: 8000} })
// {
//   url: {port: 8000}
// }
</pre>
<span>上面代码的原意是将url.port改成8000，url.host不变。实际结果却是options.url覆盖掉DEFAULTS.url，所以url.host就不存在了。</span>
						</p>
						<h3>9.6 属性的可枚举性</h3>
						<p>
<span>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</span>
<pre>
let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
</pre>
<span>描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。</span>
<span>ES5有三个操作会忽略enumerable为false的属性。</span>
<span>for...in循环：只遍历对象自身的和继承的可枚举的属性<br>
Object.keys()：返回对象自身的所有可枚举的属性的键名<br>
JSON.stringify()：只串行化对象自身的可枚举的属性</span>
<span>ES6新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</span>
<span>这四个操作之中，只有for...in会返回继承的属性。实际上，引入enumerable的最初目的，就是让某些属性可以规避掉for...in操作。比如，对象原型的toString方法，以及数组的length属性，就通过这种手段，不会被for...in遍历到。</span>
<pre>
Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable
// false

Object.getOwnPropertyDescriptor([], 'length').enumerable
// false
</pre>
<span>上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。</span>
<span>另外，ES6规定，所有Class的原型的方法都是不可枚举的。</span>
<pre>
Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable
// false
</pre>
						</p>
						<h3>9.7 __proto__属性</h3>
						<h4>9.7.1 __proto__属性</h4>
						<p>
<span>__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</span>
<pre>
// es6的写法
var obj = {
  method: function() { ... }
};
obj.__proto__ = someOtherObj;

// es5的写法
var obj = Object.create(someOtherObj);
obj.method = function() { ... };
</pre>
<span>该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</span>
<span>在实现上，__proto__调用的是Object.prototype.__proto__，具体实现如下。</span>
<pre>
Object.defineProperty(Object.prototype, '__proto__', {
  get() {
    let _thisObj = Object(this);
    return Object.getPrototypeOf(_thisObj);
  },
  set(proto) {
    if (this === undefined || this === null) {
      throw new TypeError();
    }
    if (!isObject(this)) {
      return undefined;
    }
    if (!isObject(proto)) {
      return undefined;
    }
    let status = Reflect.setPrototypeOf(this, proto);
    if (!status) {
      throw new TypeError();
    }
  },
});
function isObject(value) {
  return Object(value) === value;
}
</pre>
<span>如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。</span>
<pre>
Object.getPrototypeOf({ __proto__: null })
// null
</pre>
						<h4>9.7.2 Object.setPrototypeOf() </h4>
						<p>
<span>Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</span>
<pre>
// 格式
Object.setPrototypeOf(object, prototype)

// 用法
var o = Object.setPrototypeOf({}, null);
</pre>
<span>该方法等同于下面的函数。</span>
<pre>
function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
</pre>
<span>下面是一个例子。</span>
<pre>
let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
</pre>
<span>上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。</span>
<span>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</span>
<pre>
Object.setPrototypeOf(1, {}) === 1 // true
Object.setPrototypeOf('foo', {}) === 'foo' // true
Object.setPrototypeOf(true, {}) === true // true
</pre>
<span>由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。</span>
<pre>
Object.setPrototypeOf(undefined, {})
// TypeError: Object.setPrototypeOf called on null or undefined

Object.setPrototypeOf(null, {})
// TypeError: Object.setPrototypeOf called on null or undefined
</pre>
						</p>
						<h4>9.7.3 Object.getPrototypeOf()  </h4>
						<p>
<span>该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象</span>
<pre>
Object.getPrototypeOf(obj);
</pre>
<span>下面是一个例子。</span>
<pre>
function Rectangle() {
  // ...
}

var rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype
// true

Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype
// false
</pre>
<span>如果参数不是对象，会被自动转为对象。</span>
<pre>
// 等同于 Object.getPrototypeOf(Number(1))
Object.getPrototypeOf(1)
// Number {[[PrimitiveValue]]: 0}

// 等同于 Object.getPrototypeOf(String('foo'))
Object.getPrototypeOf('foo')
// String {length: 0, [[PrimitiveValue]]: ""}

// 等同于 Object.getPrototypeOf(Boolean(true))
Object.getPrototypeOf(true)
// Boolean {[[PrimitiveValue]]: false}

Object.getPrototypeOf(1) === Number.prototype // true
Object.getPrototypeOf('foo') === String.prototype // true
Object.getPrototypeOf(true) === Boolean.prototype // true
</pre>
<span>如果参数是undefined或null，它们无法转为对象，所以会报错。</span>
<pre>
Object.getPrototypeOf(null)
// TypeError: Cannot convert undefined or null to object

Object.getPrototypeOf(undefined)
// TypeError: Cannot convert undefined or null to object
</pre>
						</p>
						<h3>9.8 Object.keys()，Object.values()，Object.entries() </h3>
						<p>
<span>(1) Object.keys() </span>
<span>ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</span>
<pre>
var obj = { foo: 'bar', baz: 42 };
Object.keys(obj)
// ["foo", "baz"]
</pre>
<span>ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。</span>
<pre>
let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
</pre>
<span>(2) Object.values() </span>
<span>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</span>
<pre>
var obj = { foo: 'bar', baz: 42 };
Object.values(obj)
// ["bar", 42]

var obj = { 100: 'a', 2: 'b', 7: 'c' };
Object.values(obj)
// ["b", "c", "a"]
</pre>
<span>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。</span>
<span>Object.values只返回对象自身的可遍历属性。</span>
<pre>
var obj = Object.create({}, {p: {value: 42}});
Object.values(obj) // []
</pre>
<span>上面代码中，Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的enumerable默认是false，Object.values不会返回这个属性。只要把enumerable改成true，Object.values就会返回属性p的值。</span>
<pre>
var obj = Object.create({}, {p:
  {
    value: 42,
    enumerable: true
  }
});
Object.values(obj) // [42]
</pre>
<span>Object.values会过滤属性名为 Symbol 值的属性。</span>
<pre>
Object.values({ [Symbol()]: 123, foo: 'abc' });
// ['abc']
</pre>
<span>如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。</span>
<pre>
Object.values('foo')
// ['f', 'o', 'o']
</pre>
<span>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是各个字符组成的一个数组。</span>
<span>如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。</span>
<pre>
Object.values(42) // []
Object.values(true) // []
</pre>
<span>(3) Object.entries</span>
<span>Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</span>
<pre>
var obj = { foo: 'bar', baz: 42 };
Object.entries(obj)
// [ ["foo", "bar"], ["baz", 42] ]
</pre>
<span>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</span>
<pre>
Object.entries({ [Symbol()]: 123, foo: 'abc' });
// [ [ 'foo', 'abc' ] ]
</pre>
<span>面代码中，原对象有两个属性，Object.entries只输出属性名非 Symbol 值的属性。将来可能会有Reflect.ownEntries()方法，返回对象自身的所有属性。</span>
<span>Object.entries的基本用途是遍历对象的属性。</span>
<pre>
let obj = { one: 1, two: 2 };
for (let [k, v] of Object.entries(obj)) {
  console.log(
    `${JSON.stringify(k)}: ${JSON.stringify(v)}`
  );
}
// "one": 1
// "two": 2
</pre>
<span>Object.entries方法的另一个用处是，将对象转为真正的Map结构。</span>
<pre>
var obj = { foo: 'bar', baz: 42 };
var map = new Map(Object.entries(obj));
map // Map { foo: "bar", baz: 42 }
</pre>
<span>自己实现Object.entries方法，非常简单。</span>
<pre>
// Generator函数的版本
function* entries(obj) {
  for (let key of Object.keys(obj)) {
    yield [key, obj[key]];
  }
}

// 非Generator函数的版本
function entries(obj) {
  let arr = [];
  for (let key of Object.keys(obj)) {
    arr.push([key, obj[key]]);
  }
  return arr;
}
</pre>
						</p>
						<h3>9.9 Object.getOwnPropertyDescriptors()  </h3>
						<p>
<span>ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象（descriptor）。</span>
<pre>
var obj = { p: 'a' };

Object.getOwnPropertyDescriptor(obj, 'p')
// Object { value: "a",
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
</pre>
<span>ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。</span>
<pre>
const obj = {
  foo: 123,
  get bar() { return 'abc' }
};

Object.getOwnPropertyDescriptors(obj)
// { foo:
//    { value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true },
//   bar:
//    { get: [Function: bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true } }
</pre>
<span>上面代码中，Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</span>
<span>该方法的实现非常容易。</span>
<pre>
function getOwnPropertyDescriptors(obj) {
  const result = {};
  for (let key of Reflect.ownKeys(obj)) {
    result[key] = Object.getOwnPropertyDescriptor(obj, key);
  }
  return result;
}
</pre>
<span>该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。</span>
<pre>
const source = {
  set foo(value) {
    console.log(value);
  }
};

const target1 = {};
Object.assign(target1, source);

Object.getOwnPropertyDescriptor(target1, 'foo')
// { value: undefined,
//   writable: true,
//   enumerable: true,
//   configurable: true }
</pre>
<span>上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</span>
<span>这时，Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法，就可以实现正确拷贝。</span>
<pre>
const source = {
  set foo(value) {
    console.log(value);
  }
};

const target2 = {};
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
Object.getOwnPropertyDescriptor(target2, 'foo')
// { get: undefined,
//   set: [Function: foo],
//   enumerable: true,
//   configurable: true }
</pre>
<span>上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。</span>
<pre>
const shallowMerge = (target, source) => Object.defineProperties(
  target,
  Object.getOwnPropertyDescriptors(source)
);
</pre>
<span>Object.getOwnPropertyDescriptors方法的另一个用处，是配合Object.create方法，将对象属性克隆到一个新对象。这属于浅拷贝。</span>
<pre>
const clone = Object.create(Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj));

// 或者

const shallowClone = (obj) => Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
</pre>
<span>另外，Object.getOwnPropertyDescriptors方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</span>
<pre>
const obj = {
  __proto__: prot,
  foo: 123,
};
</pre>
<span>ES6 规定__proto__只有浏览器要部署，其他环境不用部署。如果去除__proto__，上面代码就要改成下面这样。</span>
<pre>
const obj = Object.create(prot);
obj.foo = 123;

// 或者

const obj = Object.assign(
  Object.create(prot),
  {
    foo: 123,
  }
);
</pre>
<span>有了Object.getOwnPropertyDescriptors，我们就有了另一种写法。</span>
<pre>
const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors({
    foo: 123,
  })
);
</pre>

						</p>

						</p>
					</div>
				</div>
				<div class="col-sm-3" id="scrollspy"></div>
			</div>
		</div>
	</section>
</body>
<script>window.jQuery || document.write('<script src="js/jquery-2.1.1.min.js"><\/script>')</script>
<script src="../../static/js/dynamicscrollspy.js"></script>
<script>
  $(function() {
    $('#scrollspy').DynamicScrollspy({
      genIDs: true,
      testing: true
    });
  });
</script>
</html>