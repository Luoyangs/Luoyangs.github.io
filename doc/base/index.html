<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>博客 - @Luoyangs</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="icon" type="image/x-icon" href="../../fav.png" />
	<link rel="stylesheet" href="http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css">
	<script src="http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js"></script>
	<script src="http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js"></script>
	<script src="../../static/js/underscore-min.js"></script>
	<style>
		.navbar{border-radius: 0px;margin-bottom:0px;}
		section{background:#EBEBEB;margin-top:0px;font-family: "Helvetica Neue", Helvetica, Arial, "Microsoft Yahei", "Hiragino Sans GB", "Heiti SC", "WenQuanYi Micro Hei", sans-serif;}
		#articleList{background:#fff;padding:16px;margin-top:20px;}
		.title{font-size:26px;text-align:center;font-weight:700;}
		.sub-title{font-size:16px;text-align:center;margin-left:32px;}
		#articleList span{display:block;margin-bottom:8px;line-height:20px;}
		.danger{color:#ff3366;}
		.success{color:#4FC08D;}
		#scrollspy > .nav {padding-left: 0px;background:#fff;margin-top:20px;padding:16px;min-width:250px;}
	  /* all anchors */
	  #scrollspy .nav > li > a {padding: 3px;border-left: 0px rgba(0,0,0,0);}
	  /* first level */
	  #scrollspy .nav li >  a {padding-left: 10px;}
	  /* second */
	  #scrollspy .nav .nav li >  a {padding-left: 20px;font-size:.9em;}
	  /* third */
	  #scrollspy .nav .nav .nav li >  a {padding-left: 30px;font-size:.8em;}
	  /* fourth */
	  #scrollspy .nav .nav .nav .nav li >  a {padding-left: 40px;}
	  /* fifth */
	  #scrollspy .nav .nav .nav .nav .nav li >  a {padding-left: 50px;}
	  /* active link */
	  #scrollspy li.active > a {font-weight:bold;border-left: 2px solid gray;}
	  /* hide second level lists */
	  #scrollspy .nav .nav {display:none;}
	  /* show second-level when active */
	  #scrollspy .nav > .active > .nav {display: block;}
	  /* headings on the page (easier to see h5, h6) */
	  #scrollspy h2, #scrollspy h3, #scrollspy h4, #scrollspy h5, #scrollspy h6 {font-style: italic;}
	</style>
</head>
<body>
	<nav class="navbar navbar-inverse navbar-fixed-top">
	  <div class="container-fluid">
	    <!-- Brand and toggle get grouped for better mobile display -->
	    <div class="navbar-header">
	      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
	        <span class="sr-only">Toggle navigation</span>
	        <span class="icon-bar"></span>
	        <span class="icon-bar"></span>
	        <span class="icon-bar"></span>
	      </button>
	      <a class="navbar-brand" href="#">博客在线</a>
	    </div>

	    <!-- Collect the nav links, forms, and other content for toggling -->
	    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
	      <ul class="nav navbar-nav">
	        <li><a href="/">首页 <span class="sr-only">(current)</span></a></li>
	        <li class="active"><a href="#">学习笔记</a></li>
	        <li><a href="#">实习经验</a></li>
	      </ul>
	      <ul class="nav navbar-nav navbar-right">
	        <li><a href="#">收藏</a></li>
	        <li class="dropdown">
	          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">@Luoyangs <span class="caret"></span></a>
	          <ul class="dropdown-menu">
	            <li><a href="#"><i class="glyphicon glyphicon-phone-alt"></i>&nbsp;&nbsp;手机</a></li>
	            <li><a href="#"><i class="glyphicon glyphicon-envelope"></i>&nbsp;&nbsp;Email</a></li>
	            <li><a href="#"><i class="glyphicon glyphicon-link"></i>&nbsp;&nbsp;QQ</a></li>
	          </ul>
	        </li>
	      </ul>
	    </div><!-- /.navbar-collapse -->
	  </div><!-- /.container-fluid -->
	</nav>
	<section style="margin-top:50px;">
		<div class="container-fluid">
			<div class="container">
				<div class="col-sm-9">
					<div id="articleList">
						<p class="title">Web前端基本知识</p>
						<p class="sub-title">参考web技术文档</p>
						<span>·浏览器页面有哪三层构成，分别是什么，作用是什么?</span>
						<span>构成：结构层、表示层、行为层 </span>
						<span>分别是：HTML、CSS、JavaScript </span>
						<span>作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。</span>
						<h2>1 HTML</h2>
						<h3>1.1 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3>
						<p>
<span>（1）、声明位于文档中的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。</span>
<span>（2）、严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行。</span>
<span>（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</span>
<span>（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</span>
		        </p>
		        <h3>1.2 浏览器的内核</h3>
		        <p>
<span>（1）、 IE: trident 内核<br>
（2）、 Firefox ： gecko 内核<br>
（3）、 Safari:webkit 内核<br>
（4）、 Opera: 以前是 presto 内核， Opera 现已改用 Google Chrome 的 Blink 内核<br>
（5）、 Chrome:Blink( 基于 webkit ， Google 与 Opera Software 共同开发 )</span>
		        </p>
		        <h3>1.3 说说你对HTML5认识?</h3>
		        <p>
<span>HTML5指的是包括 HTML 、 CSS 和 JavaScript 在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（ Plug-in-Based Rich Internet Application ， RIA ），例如： AdobeFlash 、 Microsoft Silverlight 与 Oracle JavaFX 的需求，并且提供更多能有效加强网络应用的标准集。 HTML5 是 HTML 最新版本， 2014 年 10 月由万维网联盟（ W3C ）完成标准制定。目标是替换 1999 年所制定的 HTML 4.01 和 XHTML 1.0 标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。</span>
<span>HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能 Flash 被广泛使用，但安全与稳定堪忧，不适合在移动端使用（耗电、触摸、不开放）</span>
<span>HTML5增强了浏览器的原生功能，符合 HTML5 规范的浏览器功能将更加强大，减少了 Web 应用对插件的依赖，让用户体验更好，让开发更加方便，另外 W3C 从推出 HTML4.0 到 5.0 之间共经历了 17 年， HTML 的变化很小，这并不符合一个好产品的演进规则。</span>
		        </p>
						<h3>1.4 对WEB标准以及W3C的理解与认识?</h3>
		        <p>
<span>标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和 js 脚本、结构行为表现的分离、
文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，
容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性</span>
		        </p>
						<h3>1.5 对WEB标准以及W3C的理解与认识?</h3>
		        <p>
<span>标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和 js 脚本、结构行为表现的分离、
文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，
容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性</span>
		        </p>
		        <h3>1.6 HTML5行内元素有哪些?</h3>
		        <p>
<pre>
a - 锚点
abbr - 缩写
acronym - 首字
b - 粗体 ( 不推荐 )
bdo - bidi override
big - 大字体
br - 换行
cite - 引用
code - 计算机代码 ( 在引用源码的时候需要 )
dfn - 定义字段
em - 强调
font - 字体设定 ( 不推荐 )
i - 斜体
img - 图片
input - 输入框
kbd - 定义键盘文本
label - 表格标签
q - 短引用
s - 中划线 ( 不推荐 )
samp - 定义范例计算机代码
select - 项目选择
small - 小字体文本
span - 常用内联容器，定义文本内区块
strike - 中划线
strong - 粗体强调
sub - 下标
sup - 上标
textarea - 多行文本输入框
tt - 电传文本
u - 下划线
var - 定义变量
</pre>
		        </p>
		        <h3>1.7 块级元素有哪些</h3>
		        <p>
<pre>
address - 地址
blockquote - 块引用
center - 举中对齐块
dir - 目录列表
div - 常用块级容易，也是 css layout 的主要标签
dl - 定义列表
fieldset - form控制组
form - 交互表单
h3 - 大标题
h4 - 副标题
h3 - 3级标题
h4 - 4级标题
h5 - 5级标题
h6 - 6级标题
hr - 水平分隔线
isindex - input prompt
menu - 菜单列表
noframes - frames可选内容，（对于不支持 frame 的浏览器显示此区块内容
noscript - ）可选脚本内容（对于不支持 script 的浏览器显示此内容）
ol - 排序表单
p - 段落
pre - 格式化文本
table - 表格
ul - 非排序列表
</pre>
		        </p>
		        <h3>1.8 可变元素</h3>
		        <p>
<span>可变元素为根据上下文语境决定该元素为块元素或者内联元素</span>
<pre>
applet - java applet
button - 按钮
del - 删除文本
iframe - inline frame
ins - 插入的文本
map - 图片区块 (map)
object - object对象
script - 客户端脚本
</pre>
		        </p>
		        <h3>1.9 可变元素</h3>
		        <p>
<span>没有内容的 HTML 元素被称为空元素 </span>
<pre>
br //换行
hr //分隔线
input //文本框等
img //图片
link 
meta
</pre>
		        </p>
		        <h3>1.10 cookies，sessionStorage 和 localStorage 的区别?</h3>
		        <p>
<span>sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</span>
<span>sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口（或 tab ）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的</span>
<span>cookies会发送到服务器端。其余两个不会。</span>
<span>Microsoft 指出 Internet Explorer 8 增加 cookie 限制为每个域名 50 个，但 IE7 似乎也允许每个域名 50 个 cookie 。 Firefox 每个域名 cookie 限制为 50 个。 Opera 每个域名 cookie 限制为 30 个。 Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名（ name ）、值（ value ）和等号。 Opera 许 cookie 多达 4096 个字节，包括：名（ name ）、值（ value ）和等号。 Internet Explorer 允许 cookie 多达 4095 个字节，包括：名（ name ）、值（ value ）和等号。</span>
<span>区别：</span>
<pre>
- Cookie
+ 每个域名存储量比较小（各浏览器不同，大致 4K ）
+ 所有域名的存储量有限制（各浏览器不同，大致 4K ）
+ 有个数限制（各浏览器不同）
+ 会随请求发送到服务器

- LocalStorage
+ 永久存储
+ 单个域名存储量比较大（推荐 5MB ，各浏览器不同）
+ 总体数量无限制

- SessionStorage
+ 只在 Session 内有效
+ 存储量更大（推荐没有限制，但是实际上各浏览器也不同）
</pre>
		        </p>
		        <h3>1.11 link和@import的区别?</h3>
		        <p>
<pre>
XML/HTML代码
&lt;link rel='stylesheet' rev='stylesheet' href='CSS文件 ' type='text/css' media='all' /&gt;
XML/HTML代码
&lt;style type='text/css' media='screen'&gt;
@import url('CSS文件 ');
&lt;/style&gt;
</pre>
<span>两者都是外部引用CSS的方式，但是存在一定的区别：</span>
<span>区别1： link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。</span>
<span>区别2： link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。</span>
<span>区别3： link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。</span>
<span>区别4： link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。</span>
		        </p>
		        <h3>1.12 说说你对SVG理解?</h3>
		        <p>
<span>SVG可缩放矢量图形（ Scalable Vector Graphics ）是基于可扩展标记语言（ XML ），用于描述二维矢量图形的一种图形格式。 SVG 是 W3C('World Wide Web ConSortium' 即 ' 国际互联网标准组织 ') 在 2000 年 8 月制定的一种新的二维矢量图形格式，也是规范中的网络矢量图形标准。 SVG 严格遵从 XML 语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。 SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。</span>
<span style="color:red">特点：</span>
<span>(1)任意放缩：
用户可以任意缩放图像显示，而不会破坏图像的清晰度、细节等。</span>
<span>(2)文本独立：
SVG图像中的文字独立于图像，文字保留可编辑和可搜寻的状态。也不会再有字体的限制，用户系统即使没有安装某一字体，也会看到和他们制作时完全相同的画面。</span>
<span>(3)较小文件：
总体来讲，SVG文件比那些 GIF 和 JPEG 格式的文件要小很多，因而下载也很快。</span>
<span>(4)超强显示效果：
SVG图像在屏幕上总是边缘清晰，它的清晰度适合任何屏幕分辨率和打印分辨率。</span>
<span>(5)超级颜色控制：
SVG图像提供一个 1600 万种颜色的调色板，支持 ICC 颜色描述文件标准、 RGB 、线 X 填充、渐变和蒙版。</span>
<span>(6)交互 X 和智能化。 SVG 面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式 Flash 竞争的问题，另一个问题就是 SVG 的本地运行环境下的厂家支持程度。</span>
<span>浏览器支持：
Internet Explorer9，火狐，谷歌 Chrome ， Opera 和 Safari 都支持 SVG 。
IE8和早期版本都需要一个插件 - 如 Adobe SVG 浏览器，这是免费提供的。</span>
		        </p>
		        <h3>1.13 iframe有那些缺点？</h3>
		        <p>
<span>*iframe会阻塞主页面的 Onload 事件；<br>
*搜索引擎的检索程序无法解读这种页面，不利于 SEO;<br>
*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。<br>
使用iframe之前需要考虑这两个缺点。如果需要使用 iframe ，最好是通过 javascript
动态给iframe添加 src 属性值，这样可以绕开以上两个问题。</span>
		        </p>
		        <h3>1.14 如何实现浏览器内多个标签页之间的通信?</h3>
		        <p>
<span>WebSocket、 SharedWorker ；<br>
也可以调用localstorge、 cookies 等本地存储方式；<br>
localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；<br>
注意quirks： Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常；</span>
		        </p>
		        <h3>1.15 如何在页面上实现一个圆形的可点击区域？</h3>
		        <p>
a、 map+area 或者 svg<br>
b、 border-radius<br>
c、纯 js 实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等
		        </p>
		        <h3>1.16 简述一下src与href的区别？</h3>
		        <p>
src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。<br>
src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本， img 图片和 frame 等元素。<br>
&lt;script src ='js.js'&gt;&lt;/script&gt;<br>
当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。<br>
href是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加<br>
&lt;link href='common.css' rel='stylesheet'/&gt;<br>
那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。
		        </p>
		        <h3>1.17 谈谈你对canvas的理解？</h3>
		        <p>
canvas是HTML5中新增一个HTML5标签与操作canvas的javascript API，它可以实现在网页中完成动态的2D与3D图像技术。标记和 SVG以及 VML 之间的一个重要的不同是，有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。SVG 绘图很容易编辑与生成，但功能明显要弱一些。 canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。
		        </p>
		        <h3>1.18 WebSocket与消息推送？</h3>
		        <p>
<span>B/S架构的系统多使用HTTP协议，
HTTP协议的特点： <br>
1 无状态协议 <br>
2 用于通过 Internet 发送请求消息和响应消息 <br>
3 使用端口接收和发送消息，默认为80端口 底层通信还是使用Socket完成。</span>
<span>HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送（ F5 已坏） , 一些变相的解决办法：</span>
<span>(1)双向通信与消息推送<br>
轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 <br>
优点：后端程序编写比较容易。 <br>
缺点：请求中有大半是无用，浪费带宽和服务器资源。 <br>
实例：适于小型应用。</span>
<span>(2)长轮询：客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。<br> 
优点：在无消息的情况下不会频繁的请求，耗费资小。 <br>
缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ，<br> 
实例：WebQQ、 Hi 网页版、 Facebook IM 。</span>
<span>(3)长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断地往客户端输入数据。<br> 
优点：消息即时到达，不发无用请求；管理起来也相对便。 <br>
缺点：服务器维护一个长连接会增加开销。 <br>
参考：http://blog.csdn.net/xxd851116/article/details/10022015
实例：Gmail聊天</span>
<span>(4)Flash Socket：在页面中内嵌入一个使用了 Socket 类的 Flash 程序 JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。<br> 
优点：实现真正的即时通信，而不是伪即时。<br>
缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。 <br>
实例：网络互动游戏。</span>
<span>(5)Websocket:
WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。<br>
特点:<br>
a、事件驱动<br>
b、异步<br>
c、使用 ws 或者 wss 协议的客户端 socket<br>
d、能够实现真正意义上的推送功能<br>
缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别。
参考：http://www.cnblogs.com/tinywan/p/5894403.html
</span>
		        </p>
		        <h3>1.19 img的title和alt有什么区别？</h3>
		        <p>
alt 用于图片无法加载时显示 Title 为该属性提供信息，通常当鼠标滑动到元素上的时候显示
		        </p>
		        <h3>1.20 表单的基本组成部分有哪些，表单的主要用途是什么？</h3>
		        <p>
<span>组成：表单标签、表单域、表单按钮</span>
a、表单标签：这里面包含了处理表单数据所用 CGI 程序的 URL, 以及数据提交到服务器的方法。<br>
b、表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。<br>
c、表单按钮：包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。<br>
主要用途：表单在网页中主要负责数据采集的功能，和向服务器传送数据。

		        </p>
		        <h3>1.21 表单提交中Get和Post方式的区别？</h3>
		        <p>
(1)、 get 是从服务器上获取数据， post 是向服务器传送数据。<br>
(2)、 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。<br>
(3)、 对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。<br>
(4)、 get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为 100KB 。<br>
(5)、 get 安全性非常低， post 安全性较高。
		        </p>
		        <h3>1.16 简述一下src与href的区别？</h3>
		        <p>

		        </p>
		        <h2>2 CSS</h2>
		        <h3>2.1 解释一下CSS的盒子模型？</h3>
		        <p>
a、标准的css盒子模型：宽度=内容的宽度+边框的宽度+加上内边具的宽度<br>
b、网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。<br>
c、这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所
		        </p>
		        <h3>2.2 CSS选择器的类型有哪些</h3>
		        <p>
类型：基础的选择器、组合选择器、属性选择器、伪类、伪元素<br>
(1)基础的选择器:通用*，类.，ID#，标签
(2)组合选择器:多元素（#div,p）,后代（div p）,子元素（ul > li）,兄弟（p + p）
(3)属性选择器:p[title],p[title="name"],p[title~="name"],p[lang|=en]
(4)伪类：:first-child,:link,:visited,:actived,:hover,:focus
(5)伪元素： ::first-line,::first-letter,::before,::after
		        </p>
		        <h3>2.3 伪类与伪元素？</h3>
		        <p>
(1)伪类<br>
伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。
(2)伪元素<br>
伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。
		        </p>
		        <h3>2.4 CSS有什么特殊性?（优先级、计算特殊值）？</h3>
		        <p>
优先级<br>
(1)、同类型，同级别的样式后者先于前者<br>
(2))、ID > 类样式 > 标签 > *<br>
(3)、内联>ID选择器>伪类>属性选择器>类选择器>标签选择器>通用选择器(*)>继承的样式<br>
(4)、具体 > 泛化的，特殊性即css优先级<br>
(5)、近的 > 远的 (内嵌样式 > 内部样式表 > 外联样式表)<br>
内嵌样式：内嵌在元素中，<br>
内部样式表：在页面中的样式，写在style中的样式<br>
外联样式表：单独存在一个css文件中，通过link引入或import导入的样式<br>
(6)、!important 权重最高，比 inline style 还要高<br>
		        </p>
		        <h3>2.5 常见浏览器兼容性问题与解决方案？</h3>
		        <p>
(1)浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同 <br>
问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。<br>
碰到频率:100%<br>
解决方案：CSS里 *{margin:0;padding:0;}<br>
备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。<br>
(2)浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大 <br>
问题症状:常见症状是IE6中后面的一块被顶到下一行<br>
碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）<br>
解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性<br>
备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。<br>
(3)浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度 <br>
问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度<br>
碰到频率：60%<br>
解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。<br>
备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。<br>
(4)浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug <br>
问题症状：IE6里的间距比超过设置的间距<br>
碰到几率：20%<br>
解决方案 ： 在display:block;后面加入display:inline;display:table;<br>
备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。<br>
(5) 浏览器兼容问题五：图片默认有间距 <br>	
问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。<br>
碰到几率：20%<br>
解决方案：使用float属性为img布局<br>
备注 ： 因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）<br>
(6) 浏览器兼容问题六：标签最低高度设置min-height不兼容 <br>
问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容<br>
碰到几率：5%<br>
解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}<br>
备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。<br>
(7)浏览器兼容问题七：透明度的兼容CSS设置 <br>
一般在ie中用的是filter:alpha(opacity=0);这个属性来设置div或者是块级元素的透明度，而在firefox中，一般就是直接使用opacity:0,对于兼容的，一般的做法就是在书写css样式的将2个都写上就行，就能实现兼容
		        </p>
		        <h3>2.6 如何居中div, 如何居中一个浮动元素?</h3>
		        <p>
(1)、非浮动元素居中：可以设置 margin:0 auto 令其居中, 定位 ,父级元素text-algin:center等等<br>
(2)、浮动元素居中: <br>
方法一:设置当前div的宽度，然后设置margin-left:50%; position:relative; left:-250px;其中的left是宽度的一半。<br>
方法二:父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对左移动-50%。<br>
方法三:position定位等等。
		        </p>
						<h3>2.7 几种清除浮动的方法(至少两种)?</h3>
		        <p>
(1)、父级div定义 height <br>
原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。<br> 
优点：简单、代码少、容易掌握 <br>
缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 <br>
建议：不推荐使用，只建议高度固定的布局时使用 <br>
(2)、结尾处加空div标签 clear:both <br>
原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 <br>
优点：简单、代码少、浏览器支持好、不容易出现怪问题 <br>
缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 <br>
建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 <br>
(3)、父级div定义 伪类:after 和 zoom <br>
原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 <br>
优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）<br> 
缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 <br>
建议：推荐使用，建议定义公共类，以减少CSS代码。<br>
(4)、父级div定义 overflow:hidden <br>
原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 <br>
优点：简单、代码少、浏览器支持好 <br>
缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。<br>
建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。<br>
(5)、父级div定义 overflow:auto <br>
原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度 <br>
优点：简单、代码少、浏览器支持好 <br>
缺点：内部宽高超过父级div时，会出现滚动条。 <br>
建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧
		        </p>
		        <h3>2.8 什么叫优雅降级和渐进增强？</h3>
		        <p>
优雅降级： Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.<br>
渐进增强： 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
		        </p>
		        <h3>2.9 你有哪些性能优化的方法？</h3>
		        <p>
(1)、减少HTTP请求次数 <br>
(2)、使用CDN<br>
(3)、避免空的src和href<br>
(4)、为文件头指定Expires<br>
(5)、使用gzip压缩内容<br>
(6)、把CSS放到顶部<br>
(7)、把JS放到底部<br>
(8)、避 免使用CSS表达式 <br>
(9)、将CSS和JS放到外部文件中 <br>
(10)、避免跳转 <br>
(11)、可缓存的AJAX <br>
(12)、使用GET来完成AJAX请求
		        </p>
		        <h3>2.10 为什么要初始化CSS样式？</h3>
		        <p>
因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。
当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。
*最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议）
		        </p>
		        <h3>2.11 谈谈你对CSS中刻度的认识？</h3>
		        <p>
在CSS中刻度是用于设置元素尺寸的单位。<br>
a、特殊值0可以省略单位。例如：margin:0px可以写成margin:0 <br>
b、一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。 <br>
c、长度单位包括：相对单位和绝对单位。 <br>
相对长度单位有： em, ex, ch, rem, vw, vh, vmax, vmin <br>
绝对长度单位有： cm, mm, q, in, pt, pc, px<br>
绝对长度单位：1in = 2.54cm = 25.4 mm = 72pt = 6pc = 96px<br>
文本相对长度单位：em <br>
相对长度单位是相对于当前对象内文本的字体尺寸，如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(相对父元素的字体大小倍数)<br>
body { font-size: 14px; }<br>
h1 { font-size: 16px; }<br>
.size1 p { font-size: 1em; }<br>
.size2 p { font-size: 2em; }<br>
.size3 p { font-size: 3em; }<br>
文本相对长度单位：rem <br>
rem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数<br>
只相对于根元素的大小 <br>
浏览器的默认字体大小为16像素，浏览器默认样式也称为user agent stylesheet，就是所有浏览器内置的默认样式，多数是可以被修改的，但chrome不能直接修改，可以被用户样式覆盖。<br>
em与rem的重要区别： 它们计算的规则一个是依赖父元素另一个是依赖根元素计算
		        </p>
		        <h3>2.12 请你说说box-sizing属性的的用法？</h3>
		        <p>
设置或检索对象的盒模型组成模式<br>
a、box-sizing:content-box： padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding，但占有页面位置还要加上margin ) 此属性表现为标准模式下的盒模型。<br>
b、box-sizing:border-box： padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width ) 此属性表现为怪异模式下的盒模型。
		        </p>
		        <h3>2.13 浏览器标准模式和怪异模式之间的区别是什么？</h3>
		        <p>
在“标准模式”(Standards Mode) 页面按照 HTML 与 CSS 的定义渲染，而在“怪异模式”(Quirks Mode)就是浏览器为了兼容很早之前针对旧版本浏览器设计、并未严格遵循 W3C 标准的网页而产生的一种页面渲染模式。浏览器基于页面中文件类型描述的存在以决定采用哪种渲染模式；如果存在一个完整的`DOCTYPE`则浏览器将会采用标准模式，而如果它缺失则浏览器将会采用怪异模式。<br>
（1）盒模型： <br>
在怪异模式下，盒模型为IE盒模型而非标准模式下的W3C 盒模型：在 IE 盒模型中，<br>
box width = content width + padding left + padding right + border left + border right，<br>
box height = content height + padding top + padding bottom + border top + border bottom。<br>
而在 W3C 标准的盒模型中，box 的大小就是 content 的大小。<br>
（2）图片元素的垂直对齐方式: <br>
对于`inline`元素和`table-cell`元素，在 IE Standards Mode 下 vertical-align 属性默认取值为`baseline`。而当`inline`元素的内容只有图片时，如`table`的单元格`table-cell`。在 IE Quirks Mode 下，`table`单元格中的图片的 `vertical-align` 属性默认为`bottom`，因此，在图片底部会有几像素的空间。<br>
（3）`table`元素中的字体: <br>
CSS 中，描述`font`的属性有`font-family`，`font-size`，`font-style`，`font-weigh`,上述属性都是可以继承的。而在 IE Quirks Mode 下，对于`table` 元素，字体的某些属性将不会从`body`或其他封闭元素继承到`table`中，特别是 `font-size`属性。<br>
（4） 内联元素的尺寸: <br>
在 IE Standards Mode 下，non-replaced inline 元素无法自定义大小，而在 IE Quirks Mode 下，定义这些元素的`width`和`height` 属性，能够影响该元素显示的大小尺寸。<br>
a、CSS 中对于元素的百分比高度规定如下，百分比为元素包含块的高度，不可为负值。如果包含块的高度没有显式给出，该值等同于“auto”（即取决于内容的高度）。所以百分比的高度必须在父元素有声明高度时使用。<br>
b、当一个元素使用百分比高度时，在 IE Standards Mode 下，高度取决于内容的变化，而在 Quirks Mode 下，百分比高度则被正确应用。<br>
（6） 元素溢出的处理： <br>
在 IE Standard Mode 下，`overflow`取默认值 `visible`，即溢出可见，这种情况下，溢出内容不会被裁剪，呈现在元素框外。而在 Quirks Mode 下，该溢出被当做扩展`box`来对待，即元素的大小由其内容决定，溢出不会被裁剪，元素框自动调整，包含溢出内容。
		        </p>
		        <h3>2.14 说说你对边距折叠的理解?</h3>
		        <p>
外边距折叠： 相邻的两个或多个外边距 (margin) 在垂直方向会合并成一个外边距（margin）<br>
相邻： 没有被非空内容、padding、border 或 clear 分隔开的margin特性. 非空内容就是说这元素之间要么是兄弟关系或者父子关系<br>
垂直方向外边距合并计算: <br>
a、参加折叠的margin都是正值：取其中 margin 较大的值为最终 margin 值。<br>
b、参与折叠的 margin 都是负值：取的是其中绝对值较大的，然后，从 0 位置，负向位移。<br>
c、参与折叠的 margin 中有正值，有负值：先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。
		        </p>
		        <h3>2.15 说说隐藏元素的方式有哪些？</h3>
		        <p>
a、使用CSS的display:none，不会占有原来的位置<br>
b、使用CSS的visibility:hidden，会占有原来的位置<br>
c、使用HTML5中的新增属性hidden="hidden"，不会占有原来的位置
		        </p>
		        <h3>2.16 为什么重置浏览器默认样式，如何重置默浏览器认样式？</h3>
		        <p>
每种浏览器都有一套默认的样式表，即user agent stylesheet，网页在没有指定的样式时，按浏览器内置的样式表来渲染。这是合理的，像word中也有一些预留样式，可以让我们的排版更美观整齐。不同浏览器甚至同一浏览器不同版本的默认样式是不同的。但这样会有很多兼容问题。
a、最简单的办法：（不推荐使用）*{margin: 0;padding: 0;}。<br>
b、使用CSSReset可以将所有浏览器默认样式设置成一样。<br>
c、normalize：也许有些cssreset过于简单粗暴，有点伤及无辜，normalize是另一个选择。bootstrap已经引用该css来重置浏览器默认样式，比普通的cssreset要精细一些，保留浏览器有用的默认样式，支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化
		        </p>
		        <h3>2.17 说说你对页面中使用定位(position)的理解？</h3>
		        <p>
position：static | relative | absolute | fixed | center | page | sticky <br>
默认值：static.  center、page、sticky是CSS3中新增加的值。<br>
(1)、static <br>
可以认为静态的，默认元素都是静态的定位，对象遵循常规流。此时4个定位偏移属性不会被应用，也就是使用left，right，bottom，top将不会生效。<br>
(2)、relative <br>
相对定位，对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。<br>
(3)、absolute <br>
a、绝对定位，对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。<br>
b、元素定位参考的是离自身最近的定位祖先元素，要满足两个条件，第一个是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择body为对照对象。第二个条件是要求祖先元素必须定位，通俗说就是position的属性值为非static都行。<br>
(4)、fixed <br>
固定定位，与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。<br>
(5)、center <br>
与absolute一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。（CSS3）<br>
(6)、page <br>
与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。（CSS3）<br>
(7)、sticky <br>
对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3）

		        </p>
		        <h3>2.18 如何解决多个元素重叠问题？</h3>
		        <p>
使用z-index属性可以设置元素的层叠顺序 <br>
z-index属性<br>
语法：z-index: auto | integer<br>
默认值：auto<br>
适用于：定位元素。即定义了position为非static的元素<br>
取值： <br>
auto： 元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。 <br>
整数： 用整数值来定义堆叠级别。可以为负值。 说明： <br>
检索或设置对象的层叠顺序。 <br>
z-index用于确定元素在当前层叠上下文中的层叠级别，并确定该元素是否创建新的局部层叠上下文。 <br>
当多个元素层叠在一起时，数字大者将显示在上面。
		        </p>
		        <h3>2.19 页面布局的方式有哪些？</h3>
		        <p>
方式：双飞翼、多栏、弹性、流式、瀑布流、响应式布局<br>
（1）、双飞翼布局  <br>
经典三列布局，也叫做圣杯布局【Holy Grail of Layouts】是Kevin Cornell在2006年提出的一个布局模型概念，在国内最早是由淘宝UED的工程师传播开来，在中国也有叫法是双飞翼布局，它的布局要求有几点：
a、三列布局，中间宽度自适应，两边定宽；  <br>
b、中间栏要在浏览器中优先展示渲染；  <br>
c、允许任意列的高度最高； <br>
d、要求只用一个额外的DIV标签；  <br>
e、要求用最简单的CSS、最少的HACK语句； <br>
在不增加额外标签的情况下，圣杯布局已经非常完美，圣杯布局使用了相对定位，以后布局是有局限性的，而且宽度控制要改的地方也多。在淘宝UED（User Experience Design）探讨下，增加多一个div就可以不用相对布局了，只用到了浮动和负边距，这就是我们所说的双飞翼布局。<br>
(2)、多栏布局  <br>
a、栏栅格系统：就是利用浮动实现的多栏布局，在bootstrap中用的非常多。 <br>
b、多列布局：栅格系统并没有真正实现分栏效果（如word中的分栏），CSS3为了满足这个要求增加了多列布局模块<br>
(3)、弹性布局（Flexbox）  <br>
CSS3引入了一种新的布局模式——Flexbox布局，即伸缩布局盒模型（Flexible Box），用来提供一个更加有效的方式制定、调整和分布一个容器里项目布局，即使它们的大小是未知或者动态的，这里简称为Flex。<br>
Flexbox布局常用于设计比较复杂的页面，可以轻松的实现屏幕和浏览器窗口大小发生变化时保持元素的相对位置和大小不变，同时减少了依赖于浮动布局实现元素位置的定义以及重置元素的大小。<br>
Flexbox布局在定义伸缩项目大小时伸缩容器会预留一些可用空间，让你可以调节伸缩项目的相对大小和位置。例如，你可以确保伸缩容器中的多余空间平均分配多个伸缩项目，当然，如果你的伸缩容器没有足够大的空间放置伸缩项目时，浏览器会根据一定的比例减少伸缩项目的大小，使其不溢出伸缩容器。<br>
综合而言，Flexbox布局功能主要具有以下几点： <br>
a、屏幕和浏览器窗口大小发生改变也可以灵活调整布局； <br>
b、可以指定伸缩项目沿着主轴或侧轴按比例分配额外空间（伸缩容器额外空间），从而调整伸缩项目的大小；
c、可以指定伸缩项目沿着主轴或侧轴将伸缩容器额外空间，分配到伸缩项目之前、之后或之间； <br>
d、可以指定如何将垂直于元素布局轴的额外空间分布到该元素的周围； <br>
e、可以控制元素在页面上的布局方向； <br>
f、可以按照不同于文档对象模型（DOM）所指定排序方式对屏幕上的元素重新排序。也就是说可以在浏览器渲染中不按照文档流先后顺序重排伸缩项目顺序。<br>
(4)、瀑布流布局  <br>
瀑布流布局是流式布局的一种。是当下比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。<br>
优点  <br>
a、有效的降低了界面复杂度，节省了空间：我们不再需要臃肿复杂的页码导航链接或按钮了。 <br>
b、对触屏设备来说，交互方式更符合直觉：在移动应用的交互环境当中，通过向上滑动进行滚屏的操作已经成为最基本的用户习惯，而且所需要的操作精准程度远远低于点击链接或按钮。<br>
c、更高的参与度：以上两点所带来的交互便捷性可以使用户将注意力更多的集中在内容而不是操作上，从而让他们更乐于沉浸在探索与浏览当中。
缺点  <br>
a、有限的用例： <br>
无限滚动的方式只适用于某些特定类型产品当中一部分特定类型的内容。  <br>
例如，在电商网站当中，用户时常需要在商品列表与详情页面之间切换，这种情况下，传统的、带有页码导航的方式可以帮助用户更稳妥和准确的回到某个特定的列表页面当中。 <br>
b、额外的复杂度： <br>
那些用来打造无限滚动的JS库虽然都自称很容易使用，但你总会需要在自己的产品中进行不同程度的定制化处理，以满足你们自己的需求;另外这些JS库在浏览器和设备兼容性等方面的表现也参差不齐，你必须做好充分的测试与调整工作。<br>
c、再见了，页脚： <br>
如果使用了比较典型的无限滚动加载模式，这就意味着你可以和页脚说拜拜了。  <br>
最好考虑一下页脚对于你的网站，特别是用户的重要性;如果其中确实有比较重要的内容或链接，那么最好换一种更传统和稳妥的方式。
千万不要耍弄你的用户，当他们一次次的浏览到页面底部，看到页脚，却因为自动加载的内容突然出现而无论如何都无法点击页脚中的链接时，他们会变的越发愤怒。 <br>
d、集中在一页当中动态加载数据，与一页一页的输出相比，究竟那种方式更利于SEO，这是你必须考虑的问题。对于某些以类型网站来说，在这方面进行冒险是很不划算的。<br>
e、关于页面数量的印象： <br>
其实站在用户的角度来看，这一点并非负面;不过，如果对于你的网站来说，通过更多的内容页面展示更多的相关信息(包括广告)是很重要的策略，那么单页无限滚动的方式对你并不适用。<br>
(5)、流式布局（Fluid）  <br>
固定布局和流式布局在网页设计中最常用的两种布局方式。固定布局能呈现网页的原始设计效果，流式布局则不受窗口宽度影响，流式布局使用百分比宽度来限定布局元素，这样可以根据客户端分辨率的大小来进行合理的显示。<br>
(6)、响应式布局  <br>
响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。<br>
响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。随着越来越多的设计师采用这个技术，我们不仅看到很多的创新，还看到了一些成形的模式。<br>
优点  <br>
a、面对不同分辨率设备灵活性强 <br>
b、能够快捷解决多设备显示适应问题 <br>
缺点  <br>
a、兼容各种设备工作量大，效率低下 <br>
b、代码累赘，会出现隐藏无用的元素，加载时间加长 <br>
c、其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果 <br>
d、一定程度上改变了网站原有的布局结构，会出现用户混淆的情况 
		        </p>
		        <h3>2.6 说说你对页面中使用定位(position)的理解？</h3>
		        <p>
		        
		        </p>
					</div>
				</div>
				<div class="col-sm-3" id="scrollspy"></div>
			</div>
		</div>
	</section>
</body>
<script>window.jQuery || document.write('<script src="js/jquery-2.1.1.min.js"><\/script>')</script>
<script src="../../static/js/dynamicscrollspy.js"></script>
<script>
  $(function() {
    $('#scrollspy').DynamicScrollspy({
      genIDs: true,
      testing: true
    });
  });
</script>
</html>